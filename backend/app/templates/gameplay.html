{% extends "base.html" %}

{% block content %}
{{ super() }}

<div class="page-content">

<div style="text-align: center">
  <h2 class="message" id="Message"></h2>
</div>
<div class="status-bar">
  <div id="game_phase_col" class="hidden-xs hidden-sm" style="display:none">
    <h3 id="game_phase_text"></h3>
  </div>
  <div id="chips_col">
    <h3 id="StackChips_id">Chips: {{game.stack}}</h3>
  </div>
  <div>
    <h3 id="throw_id">Würfe:</h3>
    <p id="throw_number_id" hidden></p>
  </div>
  <div>
    <h3 id="waiting_id">Warten auf: {{game.moveName(game.move_user_id)}}</h3>
    <p id="UUID" hidden>{{game.UUID}}</p>
    <p id="admin_id" hidden>{{game.admin_user_id}}</p>
    <p id="first_user_id" hidden>{{game.first_user_id}}</p>
    <p id="first_user_dice_count_id" hidden>3</p>
  </div>
</div>

<h2 id="ownuser">Spieler:</h2>

<!-- Game controls: visible for active players only -->
<div id="game_controls">
  <div class="controls-main-row">
    <!-- Block 1: Action buttons -->
    <div class="controls-block1-col">
      <div id="controls_block1" class="controls-block">
        <div class="controls-btn-row">
          <div class="controls-left">
            <div class="containerturner" id='startgame_id'>
              <img src="{{ url_for('static', filename = 'image/throw_the_dice.svg')}}" alt="throw the dice">
              <button id='btn_dice' onclick="dice()" class="btn" title="Würfeln">Würfeln</button>
              <p style="text-align: center">Würfeln</p>
            </div>
          </div>
          <div class="controls-center">
            <div class="containercup" id="btn_pullup_container">
              <img src="{{ url_for('static', filename = 'image/pulldiceup.svg')}}" alt="pull dice cup up">
              <button onclick="pullup()" class="btn" title="Aufdecken">Aufdecken</button>
              <p style="text-align: center">Aufdecken</p>
            </div>
            <div class="containercup">
              <img src="{{ url_for('static', filename = 'image/pulldicedown.svg')}}" alt="pull dice cup down">
              <button onclick="pulldown()" class="btn" title="Zudecken">Zudecken</button>
              <p style="text-align: center">Zudecken</p>
            </div>
          </div>
          <div class="controls-right">
            <button class="btn btn-primary btn-endpause" id="btn_endpause" onclick="endpause_click()">Pause</button>
          </div>
        </div>
      </div>
    </div>
    <!-- Block 2: Dice cup display -->
    <div class="controls-block2-col">
      <div id="controls_block2" class="controls-block">
        <div class="dice-cup-wrapper">
          <div class="dice-cup-control">
            <div class="dice-cup-label">Würfelbecher</div>
            <div class="dice-out-label">rausgelegt</div>
            <div class="dcell dcell-cup" id="dcell0"></div>
            <div class="dcell dcell-cup" id="dcell1"></div>
            <div class="dcell dcell-cup" id="dcell2"></div>
            <div class="dcell dcell-out" id="dcell3"></div>
            <div class="dcell dcell-out" id="dcell4"></div>
            <div class="dcell dcell-out" id="dcell5"></div>
          </div>
          <div class="dice-turn-buttons" id="dice_turn_buttons">
            <div id="btn_turn_2" class="containerturner" style="display:none">
              <img src="{{ url_for('static', filename = 'image/2_6er.svg')}}" alt="Zwei Sechsen zu Eins">
              <button onclick="turnSixes(1)" class="btn" title="Zwei Sechsen zu Eins"></button>
            </div>
            <div id="btn_turn_3" class="containerturner" style="display:none">
              <img src="{{ url_for('static', filename = 'image/3_6er.svg')}}" alt="Drei Sechsen zu zwei Einsen">
              <button onclick="turnSixes(2)" class="btn" title="Drei Sechsen zu zwei Einsen"></button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Join form: visible for visitors who are not in the game -->
<div id="join_form" style="display: none;">
  <h3>Spiel läuft -- Möchtest du mitspielen?</h3>
  <p>Du wirst sofort hinzugefügt, falls die aktuelle Runde noch nicht begonnen hat.
     Ansonsten wirst du nach Ende des aktuellen Spiels hinzugefügt.</p>
  <div class="input-group" style="max-width: 400px;">
    <input id="join_name" placeholder="Spielername" type="text" class="form-control" onkeydown="if(event.key==='Enter')joinMidGame()">
    <div class="input-group-btn">
      <button class="btn btn-primary" onclick="joinMidGame()">Beitreten</button>
    </div>
  </div>
</div>

<!-- Pending notice: visible for players waiting to join -->
<div id="pending_notice" style="display: none;">
  <h3>Du bist vorgemerkt und wirst nach Ende des aktuellen Spiels hinzugefügt.</h3>
</div>

<div style="height:30px;"></div>
<table class="table table-striped table-hover table-sm" id="player_table">
  <thead>
    <tr>
      <th class="col-counter">#</th>
      <th class="col-name">Name</th>
      <th class="col-chips">Chips</th>
      <th class="col-throws">Würfe</th>
      <th class="col-dice"></th>
      <th class="col-dice"></th>
      <th class="col-dice"></th>
      <th id="halfcount_header" class="col-half">Hälften</th>
      <th id="finalcount_header" class="col-final">Runden</th>
      <th id="penalty_header" class="col-penalty" style="display:none">Strafe</th>
    </tr>
  </thead>
  <tbody id="game_tbody">
  </tbody>
</table>

<!-- Round status row: always visible -->
<div id="round_status_row" style="min-height: 40px; padding: 6px 0;"></div>

<!-- Disclosure toggle for admin & links section -->
<button class="disclosure-toggle" id="bottom_panel_toggle" onclick="toggleBottomPanel()" type="button">
  <span class="disclosure-arrow" id="disclosure_arrow"></span>
</button>

<!-- Collapsible bottom panel (hidden by default) -->
<div id="bottom_panel" class="disclosure-panel" style="display: none;">
  {% include "snippet/adminpanel.html" %}

  <!-- Share link + QR code for mid-game joining -->
  <div style="margin-top: 20px;">
    <h4 id="share_heading">Verteile diesen Link an alle Mitspieler:</h4>
    <div class="input-group" style="max-width: 500px;">
      <input id="share_link_input" type="text" class="form-control" readonly>
      <div class="input-group-btn">
        <button onclick="document.getElementById('share_link_input').select();document.execCommand('copy');" class="btn btn-outline-secondary" type="button">kopieren</button>
      </div>
    </div>
    <div id="share_qrcode" class="qr-wrapper" style="margin-top: 12px;"></div>
    <div><button id="switch_device_btn" onclick="toggleDeviceSwitch()" class="btn btn-outline-secondary btn-sm" style="margin-top: 8px;">Gerät wechseln</button></div>
  </div>
</div>

<!-- Rules display modal -->
<div id="rulesModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <span id="rulesclose" class="close" onclick="document.getElementById('rulesModal').style.display='none'">&times;</span>
      <h2 id="rules_title">Regeln</h2>
    </div>
    <div class="modal-body">
      <div id="rules_content"></div>
    </div>
  </div>
</div>

</div> <!-- /.page-content -->

{% endblock %}
{% block scripts %}
{{ super() }}
<script src="{{ url_for('static', filename='scripts/qrcode.min.js') }}"></script>
<script>
  // Handle device switch: read params from URL and set localStorage
  (function() {
    var params = new URLSearchParams(window.location.search);
    var switchId = params.get('switch_id');
    var switchName = params.get('switch_name');
    if (switchId && switchName) {
      localStorage.setItem('id', switchId);
      localStorage.setItem('name', switchName);
      params.delete('switch_id');
      params.delete('switch_name');
      var newUrl = window.location.pathname;
      var remaining = params.toString();
      if (remaining) newUrl += '?' + remaining;
      window.history.replaceState({}, '', newUrl);
    }
  })();

  (function() {
    var loc = window.location;
    var gameUUID = document.getElementById('UUID').innerHTML.replace(/['"]+/g, '');
    var fullUrl = loc.protocol + '//' + loc.host + '/game_waiting/' + gameUUID;
    document.getElementById('share_link_input').value = fullUrl;
    new QRCode(document.getElementById('share_qrcode'), {
      text: fullUrl,
      width: 160,
      height: 160,
      colorDark: '#000000',
      colorLight: '#ffffff',
      correctLevel: QRCode.CorrectLevel.M
    });
  })();

  // Toggle bottom panel (admin & links)
  function toggleBottomPanel() {
    var panel = document.getElementById('bottom_panel');
    var arrow = document.getElementById('disclosure_arrow');
    var isOpen = panel.style.display !== 'none';
    panel.style.display = isOpen ? 'none' : '';
    arrow.classList.toggle('open', !isOpen);
  }

  // Toggle between invite link and device-switch link
  var _showingDeviceSwitch = false;
  function toggleDeviceSwitch() {
    var myId = localStorage.getItem('id');
    var myName = localStorage.getItem('name');
    if (!myId || !myName) {
      alert('Du musst erst dem Spiel beitreten.');
      return;
    }
    var btn = document.getElementById('switch_device_btn');
    var linkInput = document.getElementById('share_link_input');
    var qrContainer = document.getElementById('share_qrcode');
    var loc = window.location;
    var gameUUID = document.getElementById('UUID').innerHTML.replace(/['"]+/g, '').trim();

    var heading = document.getElementById('share_heading');

    if (!_showingDeviceSwitch) {
      var deviceUrl = loc.protocol + '//' + loc.host + '/game_waiting/' + gameUUID
                    + '?switch_id=' + encodeURIComponent(myId)
                    + '&switch_name=' + encodeURIComponent(myName);
      linkInput.value = deviceUrl;
      qrContainer.innerHTML = '';
      new QRCode(qrContainer, {
        text: deviceUrl, width: 160, height: 160,
        colorDark: '#000000', colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.M
      });
      btn.textContent = 'Spieler einladen';
      heading.textContent = 'Behalte diesen Link für dich:';
      _showingDeviceSwitch = true;
    } else {
      var inviteUrl = loc.protocol + '//' + loc.host + '/game_waiting/' + gameUUID;
      linkInput.value = inviteUrl;
      qrContainer.innerHTML = '';
      new QRCode(qrContainer, {
        text: inviteUrl, width: 160, height: 160,
        colorDark: '#000000', colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.M
      });
      btn.textContent = 'Ger\u00e4t wechseln';
      heading.textContent = 'Verteile diesen Link an alle Mitspieler:';
      _showingDeviceSwitch = false;
    }
  }
</script>
<script type=text/javascript src="{{url_for('static', filename='scripts/adminpanel.js') }}">
</script>
<script type=text/javascript src="{{url_for('static', filename='scripts/socket.io.js') }}">
</script>
<script>

  // ============= H3: Sound handling =============
  var audioUnlocked = false;

  const soundDice = new Audio("{{ url_for('static', filename = 'audio/wuerfeln.mp3')}}");
  soundDice.preload = 'auto';
  const soundLift = new Audio("{{ url_for('static', filename = 'audio/hoch_die_Becher_Markus.mp3')}}");
  soundLift.preload = 'auto';
  const soundDiceY = new Audio("{{ url_for('static', filename = 'audio/wuerfelnYannick.mp3')}}");
  soundDiceY.preload = 'auto';

  // Preload
  try { soundDice.load(); soundLift.load(); soundDiceY.load(); } catch(e) {}

  // Unlock audio on first user interaction.
  // Play each element muted so the browser marks it as user-initiated.
  // (On iOS, audio.volume is read-only and always 1, so we must use .muted instead.)
  // Only pause afterwards if no real playSound() call has claimed the element
  // in the meantime (detected by .muted still being true).
  function unlockAudio() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    [soundDice, soundLift, soundDiceY].forEach(function(audio) {
      audio.muted = true;
      var p = audio.play();
      if (p) {
        p.then(function() {
          // If still muted, no real playSound happened — safe to reset.
          if (audio.muted) {
            audio.pause();
            audio.currentTime = 0;
          }
          audio.muted = false;
        }).catch(function() {
          audio.muted = false;
        });
      } else {
        // Older browser without promise-based play
        setTimeout(function() {
          if (audio.muted) {
            audio.pause();
            audio.currentTime = 0;
          }
          audio.muted = false;
        }, 250);
      }
    });
    document.removeEventListener('click', unlockAudio);
    document.removeEventListener('touchstart', unlockAudio);
    document.removeEventListener('touchend', unlockAudio);
  }
  document.addEventListener('click', unlockAudio);
  document.addEventListener('touchstart', unlockAudio);
  document.addEventListener('touchend', unlockAudio);

  function playSound(audio) {
    if (!audio) return;
    audio.muted = false;  // claim element (prevents unlock from pausing it)
    try { audio.currentTime = 0; } catch(e) {}
    var p = audio.play();
    if (p !== undefined) {
      p.catch(function(e) { console.log('Sound konnte nicht abgespielt werden:', e.message); });
    }
  }

  // ============= Helpers =============
  var _lastGameState = null;  // cache for checking player status etc.
  var _wasInRevealPhase = false; // track reveal phase to play sound only on transition
  var _currentRoundPhase = null; // track round row phase to avoid restarting countdowns
  var _lastWaitingUserId = undefined; // undefined = first load (suppress sound on page load)

  // Table ordering state
  var _tableOrder = [];          // current display order of user IDs (strings)
  var _activeRotation = [];      // persistent rotation order of active user IDs
  var _tableAnimating = false;
  var _runningAnims = [];        // active Animation objects for cancellation
  var _isFirstTableLoad = true;

  // Dice cup state
  var _diceInCup = [true, true, true];
  var _myDiceValues = [0, 0, 0];
  var _diceSwapped = [false, false, false];
  var _diceSwapCupIdx = -1;
  var _diceHiddenAfterRoll = false;
  var _diceOutAtRoll = [false, false, false];
  var _diceAnimating = false;
  var _needsDiceRestore = true;

  function getGameId() {
    var el = document.getElementById('UUID');
    return el.innerHTML.replace(/['"]+/g, '');
  }

  function getMyId() {
    return parseInt(localStorage.getItem('id'));
  }

  // C2: Updated dicehelper -- returns null for null/0/undefined
  function dicehelper(eyes) {
    if (eyes === null || eyes === undefined || eyes === 0) return null;
    switch (eyes) {
      case 1: {
        var div = document.createElement('div');
        div.className = 'dice dice-first-face';
        var span = document.createElement('span');
        span.className = 'dot';
        div.appendChild(span);
        return div;
      }
      case 2: {
        var div = document.createElement('div');
        div.className = 'dice dice-second-face';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        div.appendChild(span);
        div.appendChild(span2);
        return div;
      }
      case 3: {
        var div = document.createElement('div');
        div.className = 'dice dice-third-face';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        var span3 = document.createElement('span');
        span3.className = 'dot';
        div.appendChild(span);
        div.appendChild(span2);
        div.appendChild(span3);
        return div;
      }
      case 4: {
        var div = document.createElement('div');
        div.className = 'dice dice-fourth-face';
        var divc1 = document.createElement('div');
        divc1.className = 'dice-column';
        var divc2 = document.createElement('div');
        divc2.className = 'dice-column';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        var span3 = document.createElement('span');
        span3.className = 'dot';
        var span4 = document.createElement('span');
        span4.className = 'dot';
        divc1.appendChild(span);
        divc1.appendChild(span2);
        divc2.appendChild(span3);
        divc2.appendChild(span4);
        div.appendChild(divc1);
        div.appendChild(divc2);
        return div;
      }
      case 5: {
        var div = document.createElement('div');
        div.className = 'dice dice-fifth-face';
        var divc1 = document.createElement('div');
        divc1.className = 'dice-column';
        var divc2 = document.createElement('div');
        divc2.className = 'dice-column';
        var divc3 = document.createElement('div');
        divc3.className = 'dice-column';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        var span3 = document.createElement('span');
        span3.className = 'dot';
        var span4 = document.createElement('span');
        span4.className = 'dot';
        var span5 = document.createElement('span');
        span5.className = 'dot';
        divc1.appendChild(span);
        divc1.appendChild(span2);
        divc2.appendChild(span3);
        divc3.appendChild(span4);
        divc3.appendChild(span5);
        div.appendChild(divc1);
        div.appendChild(divc2);
        div.appendChild(divc3);
        return div;
      }
      case 6: {
        var div = document.createElement('div');
        div.className = 'dice dice-fourth-face';
        var divc1 = document.createElement('div');
        divc1.className = 'dice-column';
        var divc2 = document.createElement('div');
        divc2.className = 'dice-column';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        var span3 = document.createElement('span');
        span3.className = 'dot';
        var span4 = document.createElement('span');
        span4.className = 'dot';
        var span5 = document.createElement('span');
        span5.className = 'dot';
        var span6 = document.createElement('span');
        span6.className = 'dot';
        divc1.appendChild(span);
        divc1.appendChild(span2);
        divc1.appendChild(span3);
        divc2.appendChild(span4);
        divc2.appendChild(span5);
        divc2.appendChild(span6);
        div.appendChild(divc1);
        div.appendChild(divc2);
        return div;
      }
      default: return null;
    }
  }

  // Format a scoring object (from game.Scoring or game.Last_Scoring) into display HTML
  function formatScoringText(scoring) {
    if (!scoring) return '';
    var chipsPart;
    if (scoring.From === 'schockaus') {
      chipsPart = scoring.From_Name + '! Alle Chips an ' + scoring.To_Name;
    } else {
      chipsPart = scoring.Chips + ' Chip(s) von '
                + scoring.From_Name + ' an ' + scoring.To_Name;
    }
    return '<b>Hoch:</b> ' + scoring.High
         + ' — <b>Tief:</b> ' + scoring.Low
         + ' — ' + chipsPart;
  }

  // Append dice element if non-null
  function appendDice(container, eyes) {
    var el = dicehelper(eyes);
    if (el) container.appendChild(el);
  }

  // ============= 3D Dice Roll Animation =============
  var DICE_FACE_ROTATION = {
    1: { x: 0,   y: 0   },
    2: { x: 0,   y: -90 },
    3: { x: 90,  y: 0   },
    4: { x: -90, y: 0   },
    5: { x: 0,   y: 90  },
    6: { x: 0,   y: 180 }
  };

  function animateDiceCupRoll(oldValues, newValues, inCup) {
    var ANIM_DURATION = 2000;
    var pending = 0;

    for (var i = 0; i < 3; i++) {
      if (inCup[i] && newValues[i] > 0) pending++;
    }
    if (pending === 0) { renderDiceCup(); return; }

    _diceAnimating = true;
    var maxDelay = 0;

    for (var i = 0; i < 3; i++) {
      if (!inCup[i] || !newValues[i] || newValues[i] === 0) continue;

      var delay = Math.floor(Math.random() * 100) + 30;
      if (delay > maxDelay) maxDelay = delay;

      (function(idx, d) {
        var cupCell = document.getElementById('dcell' + idx);
        cupCell.innerHTML = '';
        cupCell.className = 'dcell dcell-cup';

        var scene = document.createElement('div');
        scene.className = 'dice-3d-scene';
        var cube = document.createElement('div');
        cube.className = 'dice-3d-cube';
        scene.appendChild(cube);
        cupCell.appendChild(scene);

        var size = scene.offsetWidth;
        if (!size || size < 10) size = 50;
        var half = (size / 2 + 1).toFixed(1);

        var faceTransforms = [
          'translateZ(' + half + 'px)',
          'rotateY(90deg) translateZ(' + half + 'px)',
          'rotateX(-90deg) translateZ(' + half + 'px)',
          'rotateX(90deg) translateZ(' + half + 'px)',
          'rotateY(-90deg) translateZ(' + half + 'px)',
          'rotateY(180deg) translateZ(' + half + 'px)'
        ];

        for (var face = 1; face <= 6; face++) {
          var faceEl = dicehelper(face);
          if (!faceEl) continue;
          faceEl.style.position = 'absolute';
          faceEl.style.top = '0';
          faceEl.style.left = '0';
          faceEl.style.width = '100%';
          faceEl.style.height = '100%';
          faceEl.style.margin = '0';
          faceEl.style.boxSizing = 'border-box';
          faceEl.style.backfaceVisibility = 'hidden';
          faceEl.style.webkitBackfaceVisibility = 'hidden';
          faceEl.style.transform = faceTransforms[face - 1];
          cube.appendChild(faceEl);
        }

        var oldFace = (oldValues[idx] > 0 && oldValues[idx] <= 6) ? oldValues[idx] : Math.ceil(Math.random() * 6);
        var oldRot = DICE_FACE_ROTATION[oldFace];
        var newRot = DICE_FACE_ROTATION[newValues[idx]];

        cube.style.transform = 'rotateX(' + oldRot.x + 'deg) rotateY(' + oldRot.y + 'deg)';

        setTimeout(function() {
          void cube.offsetHeight;
          var spinsX = (Math.floor(Math.random() * 3) + 2) * 360;
          var spinsY = (Math.floor(Math.random() * 3) + 2) * 360;
          var dirX = Math.random() > 0.5 ? 1 : -1;
          var dirY = Math.random() > 0.5 ? 1 : -1;

          cube.style.transition = 'transform ' + ANIM_DURATION + 'ms cubic-bezier(0.08, 0.82, 0.17, 1)';
          cube.style.transform = 'rotateX(' + (newRot.x + spinsX * dirX) + 'deg) rotateY(' + (newRot.y + spinsY * dirY) + 'deg)';
        }, d);
      })(i, delay);
    }

    setTimeout(function() {
      _diceAnimating = false;
      renderDiceCup();
    }, ANIM_DURATION + maxDelay + 100);
  }

  var _lastRollAnimTimer = null;

  function cancelLastRollAnim() {
    if (_lastRollAnimTimer) {
      clearTimeout(_lastRollAnimTimer);
      _lastRollAnimTimer = null;
    }
    _diceAnimating = false;
  }

  function animateLastRoll(oldValues, inCup) {
    var ANIM_DURATION = 1500;
    var pending = 0;
    for (var i = 0; i < 3; i++) {
      if (inCup[i]) pending++;
    }
    if (pending === 0) {
      _diceHiddenAfterRoll = true;
      renderDiceCup();
      return;
    }

    _diceAnimating = true;

    for (var i = 0; i < 3; i++) {
      if (!inCup[i]) continue;

      (function(idx) {
        var cupCell = document.getElementById('dcell' + idx);
        cupCell.innerHTML = '';
        cupCell.className = 'dcell dcell-cup';

        var randomTarget = Math.ceil(Math.random() * 6);

        var scene = document.createElement('div');
        scene.className = 'dice-3d-scene';
        var cube = document.createElement('div');
        cube.className = 'dice-3d-cube';
        scene.appendChild(cube);
        cupCell.appendChild(scene);

        var size = scene.offsetWidth;
        if (!size || size < 10) size = 50;
        var half = (size / 2 + 1).toFixed(1);

        var faceTransforms = [
          'translateZ(' + half + 'px)',
          'rotateY(90deg) translateZ(' + half + 'px)',
          'rotateX(-90deg) translateZ(' + half + 'px)',
          'rotateX(90deg) translateZ(' + half + 'px)',
          'rotateY(-90deg) translateZ(' + half + 'px)',
          'rotateY(180deg) translateZ(' + half + 'px)'
        ];

        for (var face = 1; face <= 6; face++) {
          var faceEl = dicehelper(face);
          if (!faceEl) continue;
          faceEl.style.position = 'absolute';
          faceEl.style.top = '0';
          faceEl.style.left = '0';
          faceEl.style.width = '100%';
          faceEl.style.height = '100%';
          faceEl.style.margin = '0';
          faceEl.style.boxSizing = 'border-box';
          faceEl.style.backfaceVisibility = 'hidden';
          faceEl.style.webkitBackfaceVisibility = 'hidden';
          faceEl.style.transform = faceTransforms[face - 1];
          cube.appendChild(faceEl);
        }

        var oldFace = (oldValues[idx] > 0 && oldValues[idx] <= 6) ? oldValues[idx] : Math.ceil(Math.random() * 6);
        var oldRot = DICE_FACE_ROTATION[oldFace];
        var newRot = DICE_FACE_ROTATION[randomTarget];

        cube.style.transform = 'rotateX(' + oldRot.x + 'deg) rotateY(' + oldRot.y + 'deg)';

        setTimeout(function() {
          void cube.offsetHeight;
          var spinsX = (Math.floor(Math.random() * 3) + 2) * 360;
          var spinsY = (Math.floor(Math.random() * 3) + 2) * 360;
          var dirX = Math.random() > 0.5 ? 1 : -1;
          var dirY = Math.random() > 0.5 ? 1 : -1;

          cube.style.transition = 'transform ' + ANIM_DURATION + 'ms linear';
          cube.style.transform = 'rotateX(' + (newRot.x + spinsX * dirX) + 'deg) rotateY(' + (newRot.y + spinsY * dirY) + 'deg)';

          scene.style.transition = 'opacity ' + ANIM_DURATION + 'ms ease-in';
          scene.style.opacity = '0';
        }, 30);
      })(i);
    }

    _lastRollAnimTimer = setTimeout(function() {
      _lastRollAnimTimer = null;
      _diceAnimating = false;
      _diceHiddenAfterRoll = true;
      renderDiceCup();
    }, ANIM_DURATION + 100);
  }

  // C4: Check if any non-passive, non-pending user still has hidden dice
  function isUndecided(game) {
    var undecided = false;
    game.User.forEach(function(user) {
      if (!undecided && user.Passive !== true && user.Pending_Join !== true && user.Dices.length < 3)
        undecided = true;
    });
    return undecided;
  }

  // ============= Dice cup rendering =============
  function clearSwapState() {
    _diceSwapped = [false, false, false];
    _diceSwapCupIdx = -1;
  }

  function isSwapActive() {
    return _diceSwapped[0] || _diceSwapped[1] || _diceSwapped[2];
  }

  function addPlaceholder(cell) {
    var ph = document.createElement('div');
    ph.className = 'dice dice-placeholder';
    cell.appendChild(ph);
  }

  function renderDiceCup() {
    for (var i = 0; i < 6; i++) {
      var cell = document.getElementById('dcell' + i);
      cell.innerHTML = '';
      cell.onclick = null;
      cell.className = (i < 3) ? 'dcell dcell-cup' : 'dcell dcell-out';
    }

    for (var i = 0; i < 3; i++) {
      var val = _myDiceValues[i];
      var isNull = (val === null || val === undefined);
      var cupCell = document.getElementById('dcell' + i);
      var outCell = document.getElementById('dcell' + (3 + i));

      if (isNull && _diceSwapped[i] && i === _diceSwapCupIdx) {
        appendDice(cupCell, 6);
        cupCell.classList.add('dcell-disabled');
        addPlaceholder(outCell);
        continue;
      }

      if (!val || val === 0) {
        addPlaceholder(cupCell);
        addPlaceholder(outCell);
        continue;
      }

      if (_diceInCup[i]) {
        appendDice(cupCell, val);
        cupCell.classList.add('dcell-clickable');
        cupCell.onclick = (function(idx) { return function() { toggleDice(idx); }; })(i);
        addPlaceholder(outCell);
      } else {
        addPlaceholder(cupCell);
        appendDice(outCell, val);
        if (_diceSwapped[i]) {
          outCell.classList.add('dcell-swapped', 'dcell-clickable');
          outCell.onclick = (function(idx) { return function() { undoSwap(idx); }; })(i);
        } else {
          outCell.classList.add('dcell-clickable');
          outCell.onclick = (function(idx) { return function() { toggleDice(idx); }; })(i);
        }
      }
    }

    updateTurnButtons();

    // Disable roll button if no dice are in the cup
    var anyInCup = _diceInCup[0] || _diceInCup[1] || _diceInCup[2];
    var btnDice = document.getElementById('btn_dice');
    if (btnDice) {
      if (!anyInCup) {
        btnDice.disabled = true;
      } else if (btnDice.getAttribute('data-cooldown') !== 'true') {
        btnDice.disabled = false;
      }
    }
  }

  function toggleDice(diceIdx) {
    _diceInCup[diceIdx] = !_diceInCup[diceIdx];
    renderDiceCup();
  }

  function updateTurnButtons() {
    var btn2 = document.getElementById('btn_turn_2');
    var btn3 = document.getElementById('btn_turn_3');
    btn2.style.display = 'none';
    btn3.style.display = 'none';

    if (isSwapActive()) return;
    if (_diceHiddenAfterRoll) return;

    var sixes = 0;
    for (var i = 0; i < 3; i++) {
      if (_myDiceValues[i] === 6) sixes++;
    }

    var me = _lastGameState ? _lastGameState.User.find(function(u) { return u.Id === getMyId(); }) : null;
    if (!me || me.Number_Dice === 0) return;
    var firstDiceCount = parseInt(document.getElementById('first_user_dice_count_id').innerHTML) || 3;
    var amFirst = (getMyId() == _lastGameState.First);
    var canRoll = amFirst ? me.Number_Dice < 3 : me.Number_Dice < firstDiceCount;
    if (!canRoll) return;

    if (sixes >= 3) {
      btn3.style.display = '';
    } else if (sixes >= 2) {
      btn2.style.display = '';
    }
  }

  function turnSixes(count) {
    var gameid = getGameId();
    var id = localStorage.getItem('id');
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/diceturn");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          var newVals = [res.dice1, res.dice2, res.dice3];
          for (var i = 0; i < 3; i++) {
            if (newVals[i] === null || newVals[i] === undefined || newVals[i] === 0) {
              _diceSwapCupIdx = i;
              _diceInCup[i] = true;
              _diceSwapped[i] = true;
              _myDiceValues[i] = null;
            } else if (_myDiceValues[i] === 6 && newVals[i] === 1) {
              _diceInCup[i] = false;
              _diceSwapped[i] = true;
              _myDiceValues[i] = 1;
            } else {
              _myDiceValues[i] = newVals[i];
            }
          }
          renderDiceCup();
        } else {
          alert('' + res.Message);
        }
      }
    }
    xhttp.send(JSON.stringify({ count: count }));
  }

  function undoSwap(diceIdx) {
    var remainingSwapped1s = 0;
    for (var i = 0; i < 3; i++) {
      if (i !== diceIdx && _diceSwapped[i] && _myDiceValues[i] === 1) {
        remainingSwapped1s++;
      }
    }
    var restoreIdx = null;
    if (remainingSwapped1s === 0 && _diceSwapCupIdx >= 0) {
      restoreIdx = _diceSwapCupIdx + 1;
    }

    var gameid = getGameId();
    var id = localStorage.getItem('id');
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/diceturn_undo");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          _myDiceValues[diceIdx] = 6;
          _diceSwapped[diceIdx] = false;
          if (restoreIdx !== null) {
            var cupIdx = _diceSwapCupIdx;
            _myDiceValues[cupIdx] = 6;
            _diceInCup[cupIdx] = false;
            _diceSwapped[cupIdx] = false;
            _diceSwapCupIdx = -1;
          }
          renderDiceCup();
        } else {
          alert('' + res.Message);
        }
      }
    }
    var body = { revert_index: diceIdx + 1 };
    if (restoreIdx !== null) body.restore_index = restoreIdx;
    xhttp.send(JSON.stringify(body));
  }

  // ============= Game Actions =============
  function dice() {
    var _btnDice = document.getElementById("btn_dice");
    _btnDice.disabled = true;
    _btnDice.setAttribute('data-cooldown', 'true');
    setTimeout(function () {
      _btnDice.removeAttribute('data-cooldown');
      var anyInCup = _diceInCup[0] || _diceInCup[1] || _diceInCup[2];
      _btnDice.disabled = !anyInCup;
    }, 2500);

    clearSwapState();
    document.getElementById('btn_turn_2').style.display = 'none';
    document.getElementById('btn_turn_3').style.display = 'none';

    var gameid = getGameId();
    var id = localStorage.getItem('id');

    var dicenumber = document.getElementById('Number_Dice' + id);
    if (dicenumber) {
      var dn = parseInt(dicenumber.innerHTML);
      if (dn == 0) {
        if (!_diceInCup[0] || !_diceInCup[1] || !_diceInCup[2]) {
          alert('Beim ersten Wurf alle Würfel in den Becher Packen!');
          document.getElementById("btn_dice").disabled = false;
          return;
        }
      }
    }

    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/dice");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          if (res.fallen) {
            alert('Würfel vom Tisch gefallen Schnapsrunde!');
          } else {
            playSound(soundDice);

            var firstDiceCount = document.getElementById('first_user_dice_count_id').innerHTML;
            var first_user_id = document.getElementById('first_user_id').innerHTML;
            var me = localStorage.getItem('id');
            var isLastRoll = false;

            if (first_user_id == me) {
              isLastRoll = (res.number_dice >= 3);
            } else {
              isLastRoll = (String(res.number_dice) == firstDiceCount);
            }

            var oldDiceValues = [_myDiceValues[0], _myDiceValues[1], _myDiceValues[2]];
            var rolledInCup = [_diceInCup[0], _diceInCup[1], _diceInCup[2]];

            _myDiceValues = [
              res.dice1 || 0,
              res.dice2 || 0,
              res.dice3 || 0
            ];

            if (isLastRoll) {
              _diceHiddenAfterRoll = true;
              animateLastRoll(oldDiceValues, rolledInCup);
            } else {
              _diceHiddenAfterRoll = false;
              animateDiceCupRoll(oldDiceValues, _myDiceValues, rolledInCup);
            }
          }
        } else {
          alert('' + res.Message);
        }
      }
    }
    _diceOutAtRoll = [!_diceInCup[0], !_diceInCup[1], !_diceInCup[2]];
    xhttp.send(JSON.stringify({ dice1: _diceInCup[0], dice2: _diceInCup[1], dice3: _diceInCup[2] }));
  }

  // Combined End/Pause button handler
  function endpause_click() {
    var btn = document.getElementById('btn_endpause');
    var mode = btn.getAttribute('data-mode');
    var id = localStorage.getItem('id');
    var gameid = getGameId();

    if (mode === 'pause') {
      // Check if player is currently passive -> un-pause
      var me = _lastGameState ? _lastGameState.User.find(function(u) { return u.Id === getMyId(); }) : null;
      var userstate = !(me && me.Passive);
      var xhttp = new XMLHttpRequest();
      xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/passiv");
      xhttp.setRequestHeader("Content-Type", "application/json");
      xhttp.onreadystatechange = function () {
        if (xhttp.readyState == XMLHttpRequest.DONE) {
          var res = JSON.parse(xhttp.responseText);
          if (xhttp.status != 200 && xhttp.status != 201) {
            if (res.Penalty) {
              alert(res.Message);
            } else {
              alert('' + res.Message);
            }
          }
        }
      }
      xhttp.send(JSON.stringify({ userstate: userstate }));
    } else if (mode === 'ende') {
      var xhttp = new XMLHttpRequest();
      xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/finisch");
      xhttp.setRequestHeader("Content-Type", "application/json");
      xhttp.onreadystatechange = function () {
        if (xhttp.readyState == XMLHttpRequest.DONE) {
          var res = JSON.parse(xhttp.responseText);
          if (xhttp.status != 200) { alert('' + res.Message); }
        }
      }
      xhttp.send(JSON.stringify({}));
    }
  }

  function pullup() {
    cancelLastRollAnim();
    var id = localStorage.getItem('id');
    var gameid = getGameId();
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/visible");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          _diceHiddenAfterRoll = false;
          renderDiceCup();
        } else {
          alert('' + res.Message);
        }
      }
    }
    xhttp.send(JSON.stringify({ visible: true }));
  }

  function pulldown() {
    var id = localStorage.getItem('id');
    var gameid = getGameId();
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/visible");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          _diceHiddenAfterRoll = true;
          renderDiceCup();
        } else {
          alert('' + res.Message);
        }
      }
    }
    xhttp.send(JSON.stringify({
      dice1_visible: _diceOutAtRoll[0],
      dice2_visible: _diceOutAtRoll[1],
      dice3_visible: _diceOutAtRoll[2]
    }));
  }

  // ============= Player/Admin checks =============
  function checkIfPlayer(game) {
    var myId = getMyId();
    var isPlayer = game.User.some(function(u) { return u.Id === myId; });
    var gameControls = document.getElementById('game_controls');
    var joinForm = document.getElementById('join_form');
    var pendingNotice = document.getElementById('pending_notice');

    if (!isPlayer) {
      var wasHidden = (joinForm.style.display === 'none' || joinForm.style.display === '');
      gameControls.style.display = 'none';
      joinForm.style.display = 'block';
      pendingNotice.style.display = 'none';
      if (wasHidden) {
        var joinInput = document.getElementById('join_name');
        if (joinInput) joinInput.focus();
      }
    } else {
      var me = game.User.find(function(u) { return u.Id === myId; });
      if (me && me.Pending_Join) {
        gameControls.style.display = 'none';
        joinForm.style.display = 'none';
        pendingNotice.style.display = 'block';
      } else {
        gameControls.style.display = 'block';
        joinForm.style.display = 'none';
        pendingNotice.style.display = 'none';
      }
    }
  }

  // ============= Table reorder helpers =============

  function buildSortedOrder(users, firstId) {
    var activeMap = {};
    var pending = [];
    for (var i = 0; i < users.length; i++) {
      if (users[i].Pending_Join) pending.push(users[i]);
      else activeMap[String(users[i].Id)] = users[i];
    }

    // Preserve established rotation: keep known players in their order,
    // remove departed ones, append newly active players at the end
    var newRotation = [];
    for (var i = 0; i < _activeRotation.length; i++) {
      if (activeMap[_activeRotation[i]]) newRotation.push(_activeRotation[i]);
    }
    var inRotation = {};
    for (var i = 0; i < newRotation.length; i++) inRotation[newRotation[i]] = true;
    for (var i = 0; i < users.length; i++) {
      var uid = String(users[i].Id);
      if (!users[i].Pending_Join && !inRotation[uid]) newRotation.push(uid);
    }

    // Rotate so firstId is first
    var firstIdx = -1;
    for (var i = 0; i < newRotation.length; i++) {
      if (newRotation[i] == String(firstId)) { firstIdx = i; break; }
    }
    if (firstIdx > 0) {
      newRotation = newRotation.slice(firstIdx).concat(newRotation.slice(0, firstIdx));
    }
    _activeRotation = newRotation.slice();

    var result = [];
    for (var i = 0; i < newRotation.length; i++) {
      if (activeMap[newRotation[i]]) result.push(activeMap[newRotation[i]]);
    }
    return result.concat(pending);
  }

  function getOrderIds(tbody) {
    var rows = tbody.querySelectorAll('tr');
    var ids = [];
    for (var i = 0; i < rows.length; i++) {
      if (rows[i].id && rows[i].id.startsWith('row')) {
        ids.push(rows[i].id.replace('row', ''));
      }
    }
    return ids;
  }

  function updateRowCounters(tbody) {
    var rows = tbody.querySelectorAll('tr');
    for (var i = 0; i < rows.length; i++) {
      if (rows[i].cells && rows[i].cells[0]) {
        rows[i].cells[0].textContent = i + 1;
      }
    }
  }

  function flashRowColor(rowId, cssVar) {
    var row = document.getElementById(rowId);
    if (!row) return;
    var color = getComputedStyle(document.documentElement).getPropertyValue(cssVar).trim();
    if (!color) return;
    // Animate each cell individually — <tr> background is hidden beneath
    // the cell layer in the CSS table model, so it must be per-<td>.
    var cells = row.querySelectorAll('td:not(.dice-cell)');
    for (var i = 0; i < cells.length; i++) {
      cells[i].animate([
        { backgroundColor: color },
        { backgroundColor: 'transparent' }
      ], { duration: 8000, easing: 'ease-out' });
    }
  }

  function cancelTableAnimations() {
    for (var i = 0; i < _runningAnims.length; i++) {
      _runningAnims[i].anim.cancel();
      var el = _runningAnims[i].row;
      if (_runningAnims[i].isDeparting) {
        if (el.parentNode) el.parentNode.removeChild(el);
      } else {
        el.style.transform = '';
        el.style.position = '';
        el.style.willChange = '';
      }
    }
    _runningAnims = [];
    _tableAnimating = false;
  }

  function animateTableTransition(tbody, oldSnapshot, desiredOrder, removedIds, onComplete) {
    if (_tableAnimating) cancelTableAnimations();

    // Early exit: nothing to animate
    if (removedIds.length === 0) {
      var curDom = getOrderIds(tbody);
      var match = curDom.length === desiredOrder.length;
      if (match) {
        for (var ci = 0; ci < desiredOrder.length; ci++) {
          if (curDom[ci] !== desiredOrder[ci]) { match = false; break; }
        }
      }
      if (match) {
        updateRowCounters(tbody);
        _tableOrder = desiredOrder.slice();
        if (onComplete) onComplete();
        return;
      }
    }

    _tableAnimating = true;
    _runningAnims = [];

    // ---- Phase 1: Collect departing rows ----
    // Departing rows stay in the DOM as real <tr> elements during animation.
    // They fly left while remaining rows animate to their new positions.
    var departingRows = [];
    for (var ri = 0; ri < removedIds.length; ri++) {
      var rRow = document.getElementById('row' + removedIds[ri]);
      if (rRow) departingRows.push(rRow);
    }

    // ---- Phase 2: Measure positions ----
    // Working order = current DOM (includes departing rows + new rows at end).
    var workingOrder = getOrderIds(tbody);

    var currentPositions = {};
    for (var woi = 0; woi < workingOrder.length; woi++) {
      var wuid = workingOrder[woi];
      var wRow = document.getElementById('row' + wuid);
      if (wRow) currentPositions[wuid] = wRow.getBoundingClientRect().top;
    }

    // Hide departing rows from layout, temporarily reorder to desired,
    // measure target positions, then restore — all synchronous, no paint.
    for (var hi = 0; hi < departingRows.length; hi++)
      departingRows[hi].style.display = 'none';

    for (var di = 0; di < desiredOrder.length; di++) {
      var dr = document.getElementById('row' + desiredOrder[di]);
      if (dr) tbody.appendChild(dr);
    }
    var targetPositions = {};
    for (var ti = 0; ti < desiredOrder.length; ti++) {
      var tuid = desiredOrder[ti];
      var tRow = document.getElementById('row' + tuid);
      if (tRow) targetPositions[tuid] = tRow.getBoundingClientRect().top;
    }

    // Restore: show departing rows, restore working order
    for (var shi = 0; shi < departingRows.length; shi++)
      departingRows[shi].style.display = '';

    for (var roi = 0; roi < workingOrder.length; roi++) {
      var rr = document.getElementById('row' + workingOrder[roi]);
      if (rr) tbody.appendChild(rr);
    }

    // ---- Phase 3: Calculate animation offsets ----
    var lastOldBottom = 0;
    for (var sk in oldSnapshot) {
      var sb = oldSnapshot[sk].top + oldSnapshot[sk].height;
      if (sb > lastOldBottom) lastOldBottom = sb;
    }

    var SETTLE_THRESHOLD = 15;
    var animData = [];
    for (var ai = 0; ai < desiredOrder.length; ai++) {
      var auid = desiredOrder[ai];
      var aRow = document.getElementById('row' + auid);
      if (!aRow || currentPositions[auid] === undefined
          || targetPositions[auid] === undefined) continue;

      var oldTop = oldSnapshot[auid] ? oldSnapshot[auid].top : lastOldBottom;
      var curTop = currentPositions[auid];
      var tgtTop = targetPositions[auid];

      var startOff = oldTop - curTop;
      var endOff   = tgtTop - curTop;

      if (Math.abs(startOff) < 1 && Math.abs(endOff) < 1) continue;

      animData.push({
        uid: auid, row: aRow,
        startOff: startOff, endOff: endOff,
        direction: tgtTop - oldTop,
        travelDist: Math.abs(endOff - startOff),
        oldTop: oldTop
      });
    }

    // ---- Phase 4: Stagger order (upper/lower groups) ----
    var upper = [];
    var lower = [];
    var settlers = [];
    for (var gi = 0; gi < animData.length; gi++) {
      var ad = animData[gi];
      if (ad.travelDist < SETTLE_THRESHOLD) {
        settlers.push(ad);
      } else if (ad.direction > 0) {
        upper.push(ad);
      } else {
        lower.push(ad);
      }
    }

    upper.sort(function(a, b) { return b.oldTop - a.oldTop; });
    lower.sort(function(a, b) { return a.oldTop - b.oldTop; });

    var sequence = [];
    var uIdx = 0, lIdx = 0, pickU = true;
    while (uIdx < upper.length || lIdx < lower.length) {
      if (pickU && uIdx < upper.length) {
        sequence.push(upper[uIdx++]); pickU = false;
      } else if (!pickU && lIdx < lower.length) {
        sequence.push(lower[lIdx++]); pickU = true;
      } else if (uIdx < upper.length) {
        sequence.push(upper[uIdx++]);
      } else {
        sequence.push(lower[lIdx++]);
      }
    }

    var totalRows = sequence.length;
    var stagger = totalRows > 0 ? Math.max(55, Math.min(120, 500 / totalRows)) : 80;
    var flightMs = totalRows > 0 ? Math.max(750, Math.min(1300, 550 + totalRows * 80)) : 800;

    // ---- Phase 5: Animate departing rows flying left ----
    var departDelay = 0;
    for (var dri = 0; dri < departingRows.length; dri++) {
      var dRow = departingRows[dri];
      dRow.style.position = 'relative';
      dRow.style.willChange = 'transform, opacity';
      dRow.style.pointerEvents = 'none';
      var dAnim = dRow.animate([
        { transform: 'translateX(0)',     opacity: 1, offset: 0 },
        { transform: 'translateX(-60%)',  opacity: 1, offset: 0.4 },
        { transform: 'translateX(-120%)', opacity: 0, offset: 1.0 }
      ], { duration: 500, delay: departDelay, easing: 'cubic-bezier(0.25, 0, 0.9, 0.3)', fill: 'forwards' });
      _runningAnims.push({ anim: dAnim, row: dRow, isDeparting: true });
      departDelay += 60;
    }

    // ---- Phase 6a: Settle animations (rows shifted by removals only) ----
    var baseDelay = removedIds.length > 0 ? 200 : 0;
    for (var sti = 0; sti < settlers.length; sti++) {
      var s = settlers[sti];
      s.row.style.position = 'relative';
      s.row.style.willChange = 'transform';
      var sAnim = s.row.animate([
        { transform: 'translateY(' + s.startOff + 'px)' },
        { transform: 'translateY(' + s.endOff + 'px)' }
      ], { duration: flightMs, delay: baseDelay, easing: 'ease-in-out', fill: 'both' });
      _runningAnims.push({ anim: sAnim, row: s.row });
    }

    // ---- Phase 6b: Forward animate movers ----
    // DOM stays in working (old) order → natural table stacking gives
    // lower-group rows (later in DOM) the foreground. No z-index needed.
    for (var si = 0; si < sequence.length; si++) {
      var fd = sequence[si];
      var row = fd.row;
      var delay = baseDelay + si * stagger;
      var isUpper = fd.direction > 0;

      row.style.position = 'relative';
      row.style.willChange = 'transform, opacity';

      var midOff = ((fd.startOff + fd.endOff) / 2).toFixed(1);
      var kf;
      if (isUpper) {
        kf = [
          { transform: 'translateY(' + fd.startOff + 'px) scale(1)',  opacity: 1,   offset: 0,   easing: 'cubic-bezier(0.4, 0, 0.7, 0.4)' },
          { transform: 'translateY(' + midOff + 'px) scale(0.95)',    opacity: 0.8, offset: 0.5, easing: 'cubic-bezier(0.3, 0.6, 0.6, 1)' },
          { transform: 'translateY(' + fd.endOff + 'px) scale(1)',    opacity: 1,   offset: 1.0 }
        ];
      } else {
        kf = [
          { transform: 'translateY(' + fd.startOff + 'px) scale(1)',  opacity: 1, offset: 0,   easing: 'cubic-bezier(0.4, 0, 0.7, 0.4)' },
          { transform: 'translateY(' + midOff + 'px) scale(1.04)',    opacity: 1, offset: 0.5, easing: 'cubic-bezier(0.3, 0.6, 0.6, 1)' },
          { transform: 'translateY(' + fd.endOff + 'px) scale(1)',    opacity: 1, offset: 1.0 }
        ];
      }

      var fAnim = row.animate(kf, {
        duration: flightMs,
        delay: delay,
        easing: 'linear',
        fill: 'both'
      });
      _runningAnims.push({ anim: fAnim, row: row });
    }

    // ---- Phase 7: Completion ----
    function finalize() {
      for (var i = 0; i < _runningAnims.length; i++) {
        var a = _runningAnims[i];
        a.anim.cancel();
        if (a.isDeparting) {
          if (a.row.parentNode) a.row.parentNode.removeChild(a.row);
        } else {
          a.row.style.transform = '';
          a.row.style.position = '';
          a.row.style.willChange = '';
        }
      }
      for (var i = 0; i < desiredOrder.length; i++) {
        var r = document.getElementById('row' + desiredOrder[i]);
        if (r) tbody.appendChild(r);
      }
      _runningAnims = [];
      _tableAnimating = false;
      updateRowCounters(tbody);
      _tableOrder = desiredOrder.slice();
      if (onComplete) onComplete();
    }

    if (_runningAnims.length === 0) {
      finalize();
      return;
    }

    Promise.all(_runningAnims.map(function(a) { return a.anim.finished; }))
      .then(finalize).catch(finalize);
  }

  // H2: Dynamically rebuild table rows to match game.User
  function updateTableRows(game) {
    var tbody = document.getElementById('game_tbody');
    var myId = getMyId();
    var isAdmin = game.Admins && game.Admins.indexOf(myId) !== -1;
    var showFinal = game.Ruleset && game.Ruleset.play_final;
    var halfHeader = document.getElementById('halfcount_header');
    if (halfHeader) halfHeader.style.display = showFinal ? '' : 'none';
    var finalHeader = document.getElementById('finalcount_header');

    // Check if any player has penalty > 0
    var anyPenalty = game.User.some(function(u) { return (u.Penalty_Count || 0) > 0; });
    var penaltyHeader = document.getElementById('penalty_header');
    if (penaltyHeader) penaltyHeader.style.display = anyPenalty ? '' : 'none';

    // Build current set of user IDs in table
    var existingRows = {};
    var rows = tbody.querySelectorAll('tr');
    for (var i = 0; i < rows.length; i++) {
      var rowId = rows[i].id;
      if (rowId && rowId.startsWith('row')) {
        existingRows[rowId.replace('row', '')] = rows[i];
      }
    }

    // Add/update rows for each user
    game.User.forEach(function(juser, idx) {
      var row = document.getElementById('row' + juser.Id);
      if (!row) {
        // Create new row
        row = document.createElement('tr');
        row.id = 'row' + juser.Id;
        row.innerHTML = '<td class="col-counter"></td>'
          + '<td id="user' + juser.Id + '" class="col-name"></td>'
          + '<td id="chips' + juser.Id + '" class="col-chips"></td>'
          + '<td id="Number_Dice' + juser.Id + '" class="col-throws"></td>'
          + '<td id="dice1' + juser.Id + '" class="dice-cell col-dice"></td>'
          + '<td id="dice2' + juser.Id + '" class="dice-cell col-dice"></td>'
          + '<td id="dice3' + juser.Id + '" class="dice-cell col-dice"></td>'
          + '<td id="first' + juser.Id + '" class="col-half"' + (showFinal ? '' : ' style="display:none"') + '></td>'
          + '<td id="finalcount' + juser.Id + '" class="col-final"></td>'
          + '<td id="penalty' + juser.Id + '" class="col-penalty"' + (anyPenalty ? '' : ' style="display:none"') + '></td>';
        tbody.appendChild(row);
      }

      // Counter: use first cell directly
      row.cells[0].textContent = idx + 1;

      // G5: Pending player display
      if (juser.Pending_Join) {
        row.className = 'pending-row';
      } else {
        row.className = '';
      }

      // F4: Name + admin badge + leave icon
      var nameCell = document.getElementById('user' + juser.Id);
      var nameHtml = juser.Name;

      // Second line: status and/or leave icon
      var secondLine = '';
      if (juser.Pending_Join) secondLine += '<small>(wartet)</small> ';
      // Leave icon: green if active, gray only if user can toggle it (own or admin)
      var clickable = (juser.Id === myId || isAdmin);
      var leaveIconSvg = '<svg viewBox="0 0 512 512" fill="currentColor" width="14" height="14"><path d="M497 273L329 441c-15 15-41 4.5-41-17v-96H152c-13.3 0-24-10.7-24-24v-96c0-13.3 10.7-24 24-24h136V88c0-21.4 25.9-32.1 41-17l168 168c9.3 9.4 9.3 24.6 0 34zM192 436v-40c0-6.6-5.4-12-12-12H96c-17.7 0-32-14.3-32-32V160c0-17.7 14.3-32 32-32h84c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12H96c-53 0-96 43-96 96v192c0 53 43 96 96 96h84c6.6 0 12-5.4 12-12z"/></svg>';
      if (juser.Leave_After_Game) {
        secondLine += '<span class="leave-icon leave-active"'
          + ' title="Verlassen vorgemerkt (klicken zum Aufheben)"'
          + (clickable ? ' onclick="toggle_leave(' + juser.Id + ')"' : '')
          + '>' + leaveIconSvg + '</span>';
      } else if (clickable) {
        secondLine += '<span class="leave-icon leave-inactive"'
          + ' title="Nach dem Spiel verlassen"'
          + ' onclick="toggle_leave(' + juser.Id + ')"'
          + '>' + leaveIconSvg + '</span>';
      }
      if (secondLine) nameHtml += '<div>' + secondLine + '</div>';
      nameCell.innerHTML = nameHtml;

      // Chips
      document.getElementById('chips' + juser.Id).innerHTML = juser.Chips;

      // Halfcount (only visible in finale mode)
      var hcEl = document.getElementById('first' + juser.Id);
      if (hcEl) {
        hcEl.innerHTML = juser.Halfcount;
        hcEl.style.display = showFinal ? '' : 'none';
      }

      // Finalcount (always visible — "Runden")
      var fcEl = document.getElementById('finalcount' + juser.Id);
      if (fcEl) {
        fcEl.innerHTML = juser.Finalcount;
      }

      // Penalty count
      var pcEl = document.getElementById('penalty' + juser.Id);
      if (pcEl) {
        var pc = juser.Penalty_Count || 0;
        pcEl.innerHTML = pc > 0 ? pc : '';
        pcEl.style.display = anyPenalty ? '' : 'none';
      }

      // Number of dice throws
      document.getElementById('Number_Dice' + juser.Id).innerHTML = juser.Number_Dice;

      // Dices in table
      var d1 = document.getElementById('dice1' + juser.Id);
      var d2 = document.getElementById('dice2' + juser.Id);
      var d3 = document.getElementById('dice3' + juser.Id);
      d1.innerHTML = '';
      d2.innerHTML = '';
      d3.innerHTML = '';
      if (juser.Dices && juser.Dices.length > 0) {
        for (var dn in juser.Dices) {
          var jdice = juser.Dices[dn];
          if (jdice['Dice1'] !== undefined) appendDice(d1, jdice['Dice1']);
          if (jdice['Dice2'] !== undefined) appendDice(d2, jdice['Dice2']);
          if (jdice['Dice3'] !== undefined) appendDice(d3, jdice['Dice3']);
        }
      }

      // Row background color via CSS classes (dark-mode safe)
      row.classList.remove('row-passive', 'row-normal', 'row-stripe', 'row-own-player', 'row-active-turn');
      row.style.backgroundColor = '';
      if (juser.Pending_Join) {
        // Already handled by pending-row class
      } else if (juser.Passive) {
        row.classList.add('row-passive');
      } else if (juser.Id == game.Move) {
        row.classList.add('row-active-turn');
      } else {
        row.classList.add('row-normal');
        if (idx % 2 === 1) {
          row.classList.add('row-stripe');
        }
      }
      if (juser.Id == myId) {
        row.classList.add('row-own-player');
      }
    });
  }

  // ============= Main refresh function =============
  function refresh_game(game) {
    _lastGameState = game;
    var gameid = getGameId();
    var waiting_user_id = game.Move;
    var waitinguserstorage = document.getElementById('waiting_id');
    var throwbutton = document.getElementById('startgame_id');
    var id = getMyId();
    var isAdmin = game.Admins && game.Admins.indexOf(id) !== -1;

    // Admin info
    var admininfo = document.getElementById('admin_information');
    if (admininfo) admininfo.innerHTML = 'Admin gespielte Hälften: ' + game['Game_Half_Count'];

    // H2: Toggle admin panel visibility dynamically
    var adminPanel = document.getElementById('admin_interface');
    if (adminPanel) {
      adminPanel.style.display = isAdmin ? 'block' : 'none';
    }

    // Check if player / pending / spectator
    checkIfPlayer(game);

    // Redirect to lobby if game returned to waiting
    var game_state = game['State'];
    if (game_state == 'waiting') {
      var getUrl = window.location;
      var baseUrl = getUrl.protocol + "//" + getUrl.host;
      window.location.replace(baseUrl + '/game_waiting/' + gameid);
      return;
    }

    var me_inactive = false;
    for (var num in game.User) {
      if (game.User[num]['Id'] == id && game.User[num]['Passive']) {
        me_inactive = true;
      }
    }

    // Stack chips
    document.getElementById('StackChips_id').innerHTML = 'Chips: ' + game.Stack;

    // Game phase indicator (1. Hälfte / 2. Hälfte / Finale)
    var phaseCol = document.getElementById('game_phase_col');
    var phaseText = document.getElementById('game_phase_text');
    var chipsCol = document.getElementById('chips_col');
    var showFinalPhase = game.Ruleset && game.Ruleset.play_final;
    if (showFinalPhase) {
      var phaseLabel = '';
      if (game_state == 'playfinal') {
        phaseLabel = 'Finale';
      } else if (game['Game_Half_Count'] >= 1) {
        phaseLabel = '2. H\u00e4lfte';
      } else {
        phaseLabel = '1. H\u00e4lfte';
      }
      phaseText.innerHTML = phaseLabel;
      phaseCol.style.display = '';
    } else {
      phaseCol.style.display = 'none';
    }

    // First user
    var firstuser_id = game['First'];
    document.getElementById('first_user_id').innerHTML = firstuser_id;

    // First user dice count
    for (var num in game.User) {
      if (game.User[num].Id == firstuser_id) {
        var anzahlel = document.getElementById('throw_id');
        var anzahl_number_el = document.getElementById('throw_number_id');
        anzahlel.innerHTML = 'Würfe: ' + game.User[num]['Number_Dice'];
        anzahl_number_el.innerHTML = game.User[num]['Number_Dice'];
        document.getElementById('first_user_dice_count_id').innerHTML = game.User[num]['Number_Dice'];
        break;
      }
    }

    // Game message
    var el_message = document.getElementById('Message');
    if (game.Message) {
      if (el_message.innerHTML != 'Nachricht: ' + game.Message) {
        el_message.className = "message";
        el_message.style.animation = 'none';
        el_message.offsetHeight;
        el_message.style.animation = null;
      }
      el_message.innerHTML = 'Nachricht: ' + game.Message;
    } else {
      el_message.innerHTML = '';
    }

    // Count active (non-pending) players
    var activePlayerCount = 0;
    for (var num in game.User) {
      if (!game.User[num].Pending_Join) activePlayerCount++;
    }
    var notEnoughPlayers = activePlayerCount < 2 &&
        (game_state == 'started' || game_state == 'playfinal');

    // C4: Improved "Warten auf" display
    if (notEnoughPlayers) {
      waitinguserstorage.innerHTML = 'Warten auf: Mitspieler';
    } else if (waiting_user_id == -1) {
      if (isUndecided(game)) {
        waitinguserstorage.innerHTML = 'Warten auf: Aufdecken';
      } else {
        waitinguserstorage.innerHTML = 'Warten auf: Chip Verteilung';
      }
    } else {
      // Find the waiting user's name
      for (var num in game.User) {
        if (game.User[num]['Id'] == waiting_user_id) {
          waitinguserstorage.innerHTML = 'Warten auf: ' + game.User[num]['Name'];
          break;
        }
      }
    }

    // Play "your turn" sound when the waiting user changes to me.
    // _lastWaitingUserId === undefined on first load → suppress sound on page load.
    if (_lastWaitingUserId !== undefined
        && waiting_user_id !== _lastWaitingUserId
        && waiting_user_id === id) {
      playSound(soundDiceY);
    }
    _lastWaitingUserId = waiting_user_id;

    // Sort users so the round starter is first (preserving rotation order)
    if (game.First) {
      game.User = buildSortedOrder(game.User, game.First);
    }

    // H2: Update table rows dynamically
    var tbody = document.getElementById('game_tbody');
    var desiredOrder = game.User.map(function(u) { return String(u.Id); });

    // Snapshot old positions before any DOM changes
    var oldSnapshot = {};
    var snapshotRows = tbody.querySelectorAll('tr');
    for (var si = 0; si < snapshotRows.length; si++) {
      if (snapshotRows[si].id && snapshotRows[si].id.startsWith('row')) {
        var suid = snapshotRows[si].id.replace('row', '');
        oldSnapshot[suid] = snapshotRows[si].getBoundingClientRect();
      }
    }

    // Detect removed users (in DOM but not in game data)
    var gameUserIds = {};
    game.User.forEach(function(u) { gameUserIds[String(u.Id)] = true; });
    var removedIds = [];
    Object.keys(oldSnapshot).forEach(function(uid) {
      if (!gameUserIds[uid]) removedIds.push(uid);
    });

    updateTableRows(game);

    if (_isFirstTableLoad) {
      removedIds.forEach(function(uid) {
        var r = document.getElementById('row' + uid);
        if (r && r.parentNode) r.parentNode.removeChild(r);
      });
      for (var i = 0; i < desiredOrder.length; i++) {
        var r = document.getElementById('row' + desiredOrder[i]);
        if (r) tbody.appendChild(r);
      }
      updateRowCounters(tbody);
      _tableOrder = desiredOrder.slice();
      _isFirstTableLoad = false;
    } else {
      animateTableTransition(tbody, oldSnapshot, desiredOrder, removedIds);
    }

    // C1: Restore own dice cup from server state
    var me_data = null;
    for (var num in game.User) {
      if (game.User[num].Id == id) {
        me_data = game.User[num];
        break;
      }
    }
    if (me_data) {
      // Reset dice state at the start of each round (before first roll)
      if (me_data.Number_Dice == 0) {
        _diceInCup = [true, true, true];
        _myDiceValues = [0, 0, 0];
        _diceOutAtRoll = [false, false, false];
        clearSwapState();
        _diceHiddenAfterRoll = false;
      }

      // Fill in dice values from server state (page reload or after pullup)
      if (me_data.Number_Dice > 0 && me_data.Dices && me_data.Dices.length > 0) {
        var anyFilled = false;
        for (var dn in me_data.Dices) {
          var jdice = me_data.Dices[dn];
          if (jdice['Dice1'] !== undefined && _myDiceValues[0] === 0) {
            _myDiceValues[0] = jdice['Dice1'];
            anyFilled = true;
          }
          if (jdice['Dice2'] !== undefined && _myDiceValues[1] === 0) {
            _myDiceValues[1] = jdice['Dice2'];
            anyFilled = true;
          }
          if (jdice['Dice3'] !== undefined && _myDiceValues[2] === 0) {
            _myDiceValues[2] = jdice['Dice3'];
            anyFilled = true;
          }
        }
        // After pullup reveals all dice, clear hidden state
        if (_myDiceValues[0] > 0 && _myDiceValues[1] > 0 && _myDiceValues[2] > 0) {
          _diceHiddenAfterRoll = false;
        }
        if (anyFilled) {
          _diceOutAtRoll = [!_diceInCup[0], !_diceInCup[1], !_diceInCup[2]];
        }
      } else if (me_data.Number_Dice > 0 && (!me_data.Dices || me_data.Dices.length === 0)
                 && _myDiceValues[0] === 0 && _myDiceValues[1] === 0 && _myDiceValues[2] === 0
                 && waiting_user_id != id) {
        _diceHiddenAfterRoll = true;
      }

      if (!_diceAnimating) renderDiceCup();
    }

    // End/Pause button logic
    var btnEP = document.getElementById('btn_endpause');
    var controlsRight = document.querySelector('.controls-right');
    var gameControls = document.getElementById('game_controls');
    var onlyTwoPlayers = (activePlayerCount <= 2);
    if (btnEP && me_data) {
      var isMyTurn = (id == waiting_user_id);
      var myDiceCount = me_data.Number_Dice;
      var firstDiceCount = parseInt(document.getElementById('first_user_dice_count_id').innerHTML) || 3;
      var amFirst = (id == game['First']);
      var penaltyCount = me_data.Penalty_Count || 0;
      var canPause = (game.Stack == 0 && me_data.Chips == 0 && game_state != 'playfinal');

      // Remove paused overlay by default
      gameControls.classList.remove('controls-paused');

      if (me_data.Passive && game_state == 'playfinal') {
        // Non-finalist in finale: fully disabled controls, no unpause
        btnEP.textContent = 'Pause';
        btnEP.setAttribute('data-mode', 'pause');
        btnEP.disabled = true;
        btnEP.className = 'btn btn-endpause btn-pause-locked';
        gameControls.classList.add('controls-paused');
      } else if (me_data.Passive) {
        // Player is paused: show Pause button to un-pause, gray out controls
        btnEP.textContent = 'Pause';
        btnEP.setAttribute('data-mode', 'pause');
        btnEP.disabled = false;
        btnEP.className = 'btn btn-endpause btn-pause-locked';
        gameControls.classList.add('controls-paused');
      } else if (myDiceCount == 0) {
        // Start of round: show Pause button (available to all players, not just active)
        btnEP.textContent = 'Pause';
        btnEP.setAttribute('data-mode', 'pause');
        btnEP.className = 'btn btn-primary btn-endpause';

        if (onlyTwoPlayers) {
          btnEP.disabled = true;
        } else if (game_state == 'playfinal') {
          // Finale: pause is never allowed
          btnEP.disabled = true;
        } else if (notEnoughPlayers) {
          btnEP.disabled = true;
        } else if (canPause && penaltyCount > 0) {
          // Must roll instead of pausing (penalty)
          btnEP.disabled = true;
        } else {
          // Either can legitimately pause, or pressing will trigger penalty
          btnEP.disabled = false;
        }
      } else {
        // After rolling: show Ende button
        btnEP.textContent = 'Ende';
        btnEP.setAttribute('data-mode', 'ende');
        btnEP.className = 'btn btn-primary btn-endpause';

        if (!isMyTurn || notEnoughPlayers) {
          btnEP.disabled = true;
        } else if (isSwapActive()) {
          btnEP.disabled = true;
        } else {
          // Active while player can still roll
          var canStillRoll = false;
          if (amFirst) {
            canStillRoll = myDiceCount < 3;
          } else {
            canStillRoll = myDiceCount < firstDiceCount;
          }
          btnEP.disabled = !canStillRoll;
        }
      }
    }

    // Throw button color and state
    if (notEnoughPlayers) {
      throwbutton.className = 'buttongray containerturner';
      throwbutton.disabled = true;
    } else if (id == waiting_user_id) {
      throwbutton.className = 'buttongreen containerturner';
      throwbutton.disabled = false;
    } else {
      throwbutton.className = 'buttongray containerturner';
      throwbutton.disabled = false;
    }

    // Unified round status row
    var roundRow = document.getElementById('round_status_row');
    var roundFinished = (waiting_user_id == -1);
    var needsReveal = roundFinished && isUndecided(game);

    // Aufdecken button: green when waiting for reveal and player has hidden dice
    var pullupBtn = document.getElementById('btn_pullup_container');
    if (pullupBtn) {
      var myDicesRevealed = me_data && me_data.Dices && me_data.Dices.length >= 3;
      if (needsReveal && me_data && me_data.Number_Dice > 0 && !myDicesRevealed) {
        pullupBtn.className = 'buttongreen containercup';
      } else {
        pullupBtn.className = 'containercup';
      }
    }
    var readyToDistribute = roundFinished && !needsReveal;

    // Play reveal sound only on transition into the reveal phase,
    // and only for active players who still have hidden dice
    if (needsReveal && !_wasInRevealPhase) {
      if (me_data && !me_data.Passive && !me_data.Pending_Join
          && me_data.Dices.length < 3 && me_data.Number_Dice > 0) {
        playSound(soundLift);
      }
    }
    _wasInRevealPhase = needsReveal;

    var newPhase = 'idle';
    if (readyToDistribute && game.Scoring) {
      newPhase = 'distribute';
    } else if (needsReveal) {
      newPhase = 'reveal';
    } else if (!roundFinished) {
      newPhase = 'running';
    }

    if (newPhase === 'distribute') {
      var fullInfo = formatScoringText(game.Scoring);
      if (_currentRoundPhase !== 'distribute') {
        // Flash high (green) and low (red) rows when distribute button appears
        if (game.Scoring) {
          if (game.Scoring.High_Id) flashRowColor('row' + game.Scoring.High_Id, '--flash-high');
          if (game.Scoring.Low_Id)  flashRowColor('row' + game.Scoring.Low_Id, '--flash-low');
        }
        roundRow.innerHTML = '<button class="btn btn-success" id="distribute_btn" '
          + 'onclick="distribute()" disabled>Verteilen</button> '
          + '<span id="round_info_text">' + fullInfo + '</span>';
        setTimeout(function() {
          var btn = document.getElementById('distribute_btn');
          if (btn) btn.disabled = false;
        }, 3000);
      } else {
        var infoSpan = document.getElementById('round_info_text');
        if (infoSpan) infoSpan.innerHTML = fullInfo;
      }
    } else if (newPhase === 'reveal') {
      var voteHtml = '';
      if (game.Reveal_Votes > 0) {
        voteHtml = ' <span id="reveal_votes">(' + game.Reveal_Votes + ' Stimme(n))</span>';
      }
      if (_currentRoundPhase !== 'reveal') {
        roundRow.innerHTML = '<button class="btn btn-warning" id="reveal_all_btn" onclick="vote_reveal_all()" disabled>'
          + 'Alles aufdecken</button>' + voteHtml;
        setTimeout(function() {
          var btn = document.getElementById('reveal_all_btn');
          if (btn) btn.disabled = false;
        }, 15000);
      } else {
        var existingVotes = document.getElementById('reveal_votes');
        if (game.Reveal_Votes > 0) {
          if (existingVotes) {
            existingVotes.innerHTML = '(' + game.Reveal_Votes + ' Stimme(n))';
          } else {
            var revealBtn = document.getElementById('reveal_all_btn');
            if (revealBtn) {
              revealBtn.insertAdjacentHTML('afterend', ' <span id="reveal_votes">(' + game.Reveal_Votes + ' Stimme(n))</span>');
            }
          }
        } else if (existingVotes) {
          existingVotes.remove();
        }
      }
    } else if (newPhase === 'running') {
      var lastText = formatScoringText(game.Last_Scoring);
      if (lastText) {
        roundRow.innerHTML = '<span>Letzte Runde: ' + lastText + '</span>';
      } else {
        roundRow.innerHTML = '';
      }
    } else {
      roundRow.innerHTML = '';
    }
    _currentRoundPhase = newPhase;

    // Lobby after game button
    var lobbyBtn = document.getElementById('mark_lobby_btn');
    if (lobbyBtn) {
      if (game.Lobby_After_Game) {
        lobbyBtn.className = 'btn btn-success btn-sm';
        lobbyBtn.innerHTML = 'Lobby nach dem Spiel geplant (klicken zum Aufheben)';
      } else {
        lobbyBtn.className = 'btn btn-warning btn-sm';
        lobbyBtn.innerHTML = 'Zurück zur Lobby nach dem Spiel';
      }
    }

    // H2: Update player select lists
    if (typeof updatePlayerSelects === 'function') {
      updatePlayerSelects(game);
    }

    // R6: Update rules display data
    if (game.Ruleset) {
      updateRulesModal(game.Ruleset);
    }
  }

  // R6: Build rules modal content
  function updateRulesModal(ruleset) {
    var title = document.getElementById('rules_title');
    var content = document.getElementById('rules_content');
    if (!title || !content) return;
    title.innerHTML = 'Regeln: ' + ruleset.name;
    var html = '<p><strong>Chips:</strong> ' + ruleset.stack_max + ' | <strong>Finale:</strong> ' + (ruleset.play_final ? 'Ja' : 'Nein') + '</p>';
    html += '<table class="table table-condensed rules-table"><thead><tr><th class="rules-col-kombi">Kombination</th><th>Name</th><th>Chips</th></tr></thead><tbody>';
    for (var i = 0; i < ruleset.rules.length; i++) {
      var r = ruleset.rules[i];
      html += '<tr><td class="rules-col-kombi">' + r.dice + '</td><td>' + r.name + '</td><td>' + (r.chips == -1 ? 'Alle (' + r.name + ')' : r.chips) + '</td></tr>';
    }
    html += '</tbody></table>';
    html += '<p><small>Alle weiteren Kombinationen: Schrott (1 Chip)</small></p>';
    content.innerHTML = html;
  }

  function restoreMyDice(game) {
    if (!_needsDiceRestore) return;
    _needsDiceRestore = false;

    var myId = getMyId();
    var me = null;
    for (var i = 0; i < game.User.length; i++) {
      if (game.User[i].Id === myId) { me = game.User[i]; break; }
    }
    if (!me || me.Number_Dice === 0) return;
    if (_myDiceValues[0] > 0 && _myDiceValues[1] > 0 && _myDiceValues[2] > 0) return;

    var gameid = getGameId();
    var xhttp = new XMLHttpRequest();
    xhttp.open("GET", "/api/game/" + gameid + "/user/" + myId + "/mydice");
    xhttp.onreadystatechange = function() {
      if (xhttp.readyState == XMLHttpRequest.DONE && xhttp.status == 200) {
        var res = JSON.parse(xhttp.responseText);

        _diceInCup = [!res.dice1_visible, !res.dice2_visible, !res.dice3_visible];
        _diceOutAtRoll = [res.dice1_visible, res.dice2_visible, res.dice3_visible];

        if (game.Move === myId) {
          _myDiceValues = [res.dice1 || 0, res.dice2 || 0, res.dice3 || 0];
          _diceHiddenAfterRoll = false;
        } else {
          _myDiceValues = [
            res.dice1_visible ? (res.dice1 || 0) : 0,
            res.dice2_visible ? (res.dice2 || 0) : 0,
            res.dice3_visible ? (res.dice3 || 0) : 0
          ];
          _diceHiddenAfterRoll = !res.dice1_visible || !res.dice2_visible || !res.dice3_visible;
        }

        if (!_diceAnimating) renderDiceCup();
      }
    };
    xhttp.send();
  }

  function initial_game_data() {
    var gameid = getGameId();
    var xhttp = new XMLHttpRequest();
    xhttp.open("GET", "/api/game/" + gameid);
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        if (xhttp.status == 200) {
          var res = JSON.parse(xhttp.responseText);
          refresh_game(res);
          restoreMyDice(res);
        }
      }
    }
    xhttp.send(JSON.stringify({}));
  }

  function startup() {
    var id = localStorage.getItem('id');
    var user = document.getElementById('ownuser');
    user.innerHTML = "Spieler: " + (localStorage.getItem('name') || '');
    // Pre-fill mid-game join input from localStorage
    var savedName = localStorage.getItem('name');
    if (savedName) {
      var joinInput = document.getElementById('join_name');
      if (joinInput && !joinInput.value) joinInput.value = savedName;
    }
    initial_game_data();
  }

  startup();

  document.addEventListener('DOMContentLoaded', function() {
    var container = document.getElementById('floating-icons');
    if (container) {
      var btn = document.createElement('a');
      btn.className = 'floating-icon-btn';
      btn.href = '#';
      btn.onclick = function(e) { e.preventDefault(); showRules(); };
      btn.title = 'Regeln';
      btn.innerHTML = '<svg viewBox="0 0 448 512" fill="currentColor" width="16" height="16"><path d="M448 360V24c0-13.3-10.7-24-24-24H96C43 0 0 43 0 96v320c0 53 43 96 96 96h328c13.3 0 24-10.7 24-24v-16c0-8.6-4.6-16.2-11.5-20.4-4.8-12-4.8-42.2 0-54.2 6.9-4.2 11.5-11.8 11.5-20.4zM96 404c-28.4 0-48-10.2-48-28s19.6-28 48-28h288v56H96zm0-236h288v24H96v-24z"/></svg>';
      container.insertBefore(btn, container.firstChild);
    }
    var rulesModal = document.getElementById('rulesModal');
    if (rulesModal) {
      window.addEventListener('click', function(e) {
        if (e.target === rulesModal) rulesModal.style.display = 'none';
      });
    }
  });
</script>
<script type="text/javascript" charset="utf-8">
  namespace = '/game';

  const socket = io(namespace, {
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    randomizationFactor: 0.5
  });

  socket.on('connect', function () {
    var game = document.getElementById('UUID');
    var gameid = game.innerHTML;
    gameid = gameid.replace(/^"(.+)"$/, '$1');
    socket.emit('join', { room: gameid });
  });

  socket.on('reload_game', function (game) {
    if (game) {
      refresh_game(game);
    }
  });
</script>
{% endblock %}
