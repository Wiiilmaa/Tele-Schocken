{% extends "base.html" %}

{% block content %}
{{ super() }}

<div class="row col-md-offset-1 col-xs-offset-1">
  <div class="col-md-10 col-xs-11" style="text-align: center">
    <h2 class="message" id="Message"></h2>
  </div>
</div>
<div class="container-fluid">
  <div class="row">
    <div id="game_phase_col" class="col-md-offset-1 col-md-2 hidden-xs hidden-sm" style="display:none">
      <h3 id="game_phase_text"></h3>
    </div>
    <div id="chips_col" class="col-xs-6 col-md-offset-1 col-md-2">
      <h3 id="StackChips_id">Chips: {{game.stack}}</h3>
    </div>
    <div class="col-xs-6 col-md-3">
      <h3 id="throw_id">Würfe:</h3>
      <p id="throw_number_id" hidden></p>
    </div>
    <div class="clearfix visible-xs-block visible-sm-block"></div>
    <div class="col-xs-12 col-md-3">
      <h3 id="waiting_id">Warten auf: {{game.moveName(game.move_user_id)}}</h3>
      <p id="UUID" hidden>{{game.UUID}}</p>
      <p id="admin_id" hidden>{{game.admin_user_id}}</p>
      <p id="first_user_id" hidden>{{game.first_user_id}}</p>
      <p id="first_user_dice_count_id" hidden>3</p>
    </div>
  </div>
</div>

<div class="row ">
  <div class="col-md-11 col-md-offset-1">
    <h2 id="ownuser">Spieler:</h2>
  </div>
</div>

<!-- Game controls: visible for active players only -->
<div id="game_controls">
<div class="container-fluid">
  <div class="row">
    <div class="col-xs-12 col-md-10 col-md-offset-1">
      <div class="controls-main-row">
        <!-- Block 1: Action buttons -->
        <div class="controls-block1-col">
          <div id="controls_block1" class="controls-block">
            <div class="controls-btn-row">
              <div class="controls-left">
                <div class="containerturner" id='startgame_id'>
                  <img src="{{ url_for('static', filename = 'image/throw_the_dice.svg')}}" alt="throw the dice">
                  <button id='btn_dice' onclick="dice()" class="btn" title="Würfeln">Würfeln</button>
                  <p style="text-align: center">Würfeln</p>
                </div>
              </div>
              <div class="controls-center">
                <div class="containercup">
                  <img src="{{ url_for('static', filename = 'image/pulldiceup.svg')}}" alt="pull dice cup up">
                  <button onclick="pullup()" class="btn" title="Aufdecken">Aufdecken</button>
                  <p style="text-align: center">Aufdecken</p>
                </div>
                <div class="containercup">
                  <img src="{{ url_for('static', filename = 'image/pulldicedown.svg')}}" alt="pull dice cup down">
                  <button onclick="pulldown()" class="btn" title="Zudecken">Zudecken</button>
                  <p style="text-align: center">Zudecken</p>
                </div>
              </div>
              <div class="controls-right">
                <button class="btn btn-primary btn-endpause" id="btn_endpause" onclick="endpause_click()">Pause</button>
              </div>
            </div>
          </div>
        </div>
        <!-- Block 2: Dice cup display -->
        <div class="controls-block2-col">
          <div id="controls_block2" class="controls-block">
            <div class="dice-cup-wrapper">
              <div class="dice-cup-control">
                <div class="dice-cup-label">Würfelbecher</div>
                <div class="dice-out-label">rausgelegt</div>
                <div class="dcell dcell-cup" id="dcell0"></div>
                <div class="dcell dcell-cup" id="dcell1"></div>
                <div class="dcell dcell-cup" id="dcell2"></div>
                <div class="dcell dcell-out" id="dcell3"></div>
                <div class="dcell dcell-out" id="dcell4"></div>
                <div class="dcell dcell-out" id="dcell5"></div>
              </div>
              <div class="dice-turn-buttons" id="dice_turn_buttons">
                <div id="btn_turn_2" class="containerturner" style="display:none">
                  <img src="{{ url_for('static', filename = 'image/2_6er.svg')}}" alt="Zwei Sechsen zu Eins">
                  <button onclick="turnSixes(1)" class="btn" title="Zwei Sechsen zu Eins"></button>
                </div>
                <div id="btn_turn_3" class="containerturner" style="display:none">
                  <img src="{{ url_for('static', filename = 'image/3_6er.svg')}}" alt="Drei Sechsen zu zwei Einsen">
                  <button onclick="turnSixes(2)" class="btn" title="Drei Sechsen zu zwei Einsen"></button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
</div>

<!-- Join form: visible for visitors who are not in the game -->
<div id="join_form" style="display: none;">
  <div class="container-fluid">
    <div class="row">
      <div class="col-xs-12 col-md-6 col-md-offset-1">
        <h3>Spiel läuft -- Möchtest du mitspielen?</h3>
        <p>Du wirst sofort hinzugefügt, falls die aktuelle Runde noch nicht begonnen hat.
           Ansonsten wirst du nach Ende des aktuellen Spiels hinzugefügt.</p>
        <div class="input-group" style="max-width: 400px;">
          <input id="join_name" placeholder="Spielername" type="text" class="form-control" onkeydown="if(event.key==='Enter')joinMidGame()">
          <div class="input-group-btn">
            <button class="btn btn-primary" onclick="joinMidGame()">Beitreten</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Pending notice: visible for players waiting to join -->
<div id="pending_notice" style="display: none;">
  <div class="container-fluid">
    <div class="row">
      <div class="col-xs-12 col-md-6 col-md-offset-1">
        <h3>Du bist vorgemerkt und wirst nach Ende des aktuellen Spiels hinzugefügt.</h3>
      </div>
    </div>
  </div>
</div>

<div style="height:30px;" class="row col-md-offset-1 col-xs-offset-1">
</div>
<div class="row ">
</div>
<div class="row" data-example-id="striped-table">
  <div class="col-xs-12 col-md-10 col-md-offset-1">
    <table class="table table-striped table-hover table-sm" id="player_table">
      <thead>
        <tr>
          <th class="col-counter">#</th>
          <th class="col-name">Name</th>
          <th class="col-chips">Chips</th>
          <th class="col-throws">Würfe</th>
          <th class="col-dice"></th>
          <th class="col-dice"></th>
          <th class="col-dice"></th>
          <th class="col-half">Hälften</th>
          <th id="finalcount_header" class="col-final" {% if not game.play_final %}style="display:none"{% endif %}>Runden</th>
          <th id="penalty_header" class="col-penalty" style="display:none">Strafe</th>
        </tr>
      </thead>
      <tbody id="game_tbody">
      </tbody>
    </table>
  </div>
</div>

{% include "snippet/adminpanel.html" %}

<!-- Share link + QR code for mid-game joining -->
<div class="row" style="margin-top: 20px;">
  <div class="col-xs-12 col-md-10 col-md-offset-1">
    <h4 id="share_heading">Verteile diesen Link an alle Mitspieler:</h4>
    <div class="input-group" style="max-width: 500px;">
      <input id="share_link_input" type="text" class="form-control" readonly>
      <div class="input-group-btn">
        <button onclick="document.getElementById('share_link_input').select();document.execCommand('copy');" class="btn btn-outline-secondary" type="button">kopieren</button>
      </div>
    </div>
    <div id="share_qrcode" style="margin-top: 12px; padding: 20px;"></div>
    <button id="switch_device_btn" onclick="toggleDeviceSwitch()" class="btn btn-outline-secondary btn-sm" style="margin-top: 8px;">Gerät wechseln</button>
  </div>
</div>
</div>

{% endblock %}
{% block scripts %}
{{ super() }}
<script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
<script>
  // Handle device switch: read params from URL and set localStorage
  (function() {
    var params = new URLSearchParams(window.location.search);
    var switchId = params.get('switch_id');
    var switchName = params.get('switch_name');
    if (switchId && switchName) {
      localStorage.setItem('id', switchId);
      localStorage.setItem('name', switchName);
      params.delete('switch_id');
      params.delete('switch_name');
      var newUrl = window.location.pathname;
      var remaining = params.toString();
      if (remaining) newUrl += '?' + remaining;
      window.history.replaceState({}, '', newUrl);
    }
  })();

  (function() {
    var loc = window.location;
    var gameUUID = document.getElementById('UUID').innerHTML.replace(/['"]+/g, '');
    var fullUrl = loc.protocol + '//' + loc.host + '/game_waiting/' + gameUUID;
    document.getElementById('share_link_input').value = fullUrl;
    new QRCode(document.getElementById('share_qrcode'), {
      text: fullUrl,
      width: 160,
      height: 160,
      colorDark: '#000000',
      colorLight: '#ffffff',
      correctLevel: QRCode.CorrectLevel.M
    });
  })();

  // Toggle between invite link and device-switch link
  var _showingDeviceSwitch = false;
  function toggleDeviceSwitch() {
    var myId = localStorage.getItem('id');
    var myName = localStorage.getItem('name');
    if (!myId || !myName) {
      alert('Du musst erst dem Spiel beitreten.');
      return;
    }
    var btn = document.getElementById('switch_device_btn');
    var linkInput = document.getElementById('share_link_input');
    var qrContainer = document.getElementById('share_qrcode');
    var loc = window.location;
    var gameUUID = document.getElementById('UUID').innerHTML.replace(/['"]+/g, '').trim();

    var heading = document.getElementById('share_heading');

    if (!_showingDeviceSwitch) {
      var deviceUrl = loc.protocol + '//' + loc.host + '/game_waiting/' + gameUUID
                    + '?switch_id=' + encodeURIComponent(myId)
                    + '&switch_name=' + encodeURIComponent(myName);
      linkInput.value = deviceUrl;
      qrContainer.innerHTML = '';
      new QRCode(qrContainer, {
        text: deviceUrl, width: 160, height: 160,
        colorDark: '#000000', colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.M
      });
      btn.textContent = 'Spieler einladen';
      heading.textContent = 'Behalte diesen Link für dich:';
      _showingDeviceSwitch = true;
    } else {
      var inviteUrl = loc.protocol + '//' + loc.host + '/game_waiting/' + gameUUID;
      linkInput.value = inviteUrl;
      qrContainer.innerHTML = '';
      new QRCode(qrContainer, {
        text: inviteUrl, width: 160, height: 160,
        colorDark: '#000000', colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.M
      });
      btn.textContent = 'Ger\u00e4t wechseln';
      heading.textContent = 'Verteile diesen Link an alle Mitspieler:';
      _showingDeviceSwitch = false;
    }
  }
</script>
<script type=text/javascript src="{{url_for('static', filename='scripts/adminpanel.js') }}">
</script>
<script type=text/javascript src="{{url_for('static', filename='scripts/socket.io.js') }}">
</script>
<script>

  // ============= H3: Sound handling =============
  var audioUnlocked = false;

  const soundDice = new Audio("{{ url_for('static', filename = 'audio/wuerfeln.mp3')}}");
  soundDice.preload = 'auto';
  const soundLift = new Audio("{{ url_for('static', filename = 'audio/hoch_die_Becher_Markus.mp3')}}");
  soundLift.preload = 'auto';
  const soundDiceY = new Audio("{{ url_for('static', filename = 'audio/wuerfelnYannick.mp3')}}");
  soundDiceY.preload = 'auto';

  // Preload
  try { soundDice.load(); soundLift.load(); soundDiceY.load(); } catch(e) {}

  // Unlock audio on first user interaction.
  // Play each element muted so the browser marks it as user-initiated.
  // (On iOS, audio.volume is read-only and always 1, so we must use .muted instead.)
  // Only pause afterwards if no real playSound() call has claimed the element
  // in the meantime (detected by .muted still being true).
  function unlockAudio() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    [soundDice, soundLift, soundDiceY].forEach(function(audio) {
      audio.muted = true;
      var p = audio.play();
      if (p) {
        p.then(function() {
          // If still muted, no real playSound happened — safe to reset.
          if (audio.muted) {
            audio.pause();
            audio.currentTime = 0;
          }
          audio.muted = false;
        }).catch(function() {
          audio.muted = false;
        });
      } else {
        // Older browser without promise-based play
        setTimeout(function() {
          if (audio.muted) {
            audio.pause();
            audio.currentTime = 0;
          }
          audio.muted = false;
        }, 250);
      }
    });
    document.removeEventListener('click', unlockAudio);
    document.removeEventListener('touchstart', unlockAudio);
    document.removeEventListener('touchend', unlockAudio);
  }
  document.addEventListener('click', unlockAudio);
  document.addEventListener('touchstart', unlockAudio);
  document.addEventListener('touchend', unlockAudio);

  function playSound(audio) {
    if (!audio) return;
    audio.muted = false;  // claim element (prevents unlock from pausing it)
    try { audio.currentTime = 0; } catch(e) {}
    var p = audio.play();
    if (p !== undefined) {
      p.catch(function(e) { console.log('Sound konnte nicht abgespielt werden:', e.message); });
    }
  }

  // ============= Helpers =============
  var _lastGameState = null;  // cache for checking player status etc.
  var _wasInRevealPhase = false; // track reveal phase to play sound only on transition
  var _currentRoundPhase = null; // track round row phase to avoid restarting countdowns
  var _lastWaitingUserId = undefined; // undefined = first load (suppress sound on page load)

  // Table ordering state
  var _tableOrder = [];          // current display order of user IDs (strings)
  var _activeRotation = [];      // persistent rotation order of active user IDs
  var _tableAnimating = false;
  var _runningAnims = [];        // active Animation objects for cancellation
  var _isFirstTableLoad = true;

  // Dice cup state
  var _diceInCup = [true, true, true];
  var _myDiceValues = [0, 0, 0];
  var _diceSwapped = [false, false, false];
  var _diceSwapCupIdx = -1;
  var _diceHiddenAfterRoll = false;
  var _diceOutAtRoll = [false, false, false];
  var _diceAnimating = false;

  function getGameId() {
    var el = document.getElementById('UUID');
    return el.innerHTML.replace(/['"]+/g, '');
  }

  function getMyId() {
    return parseInt(localStorage.getItem('id'));
  }

  // C2: Updated dicehelper -- returns null for null/0/undefined
  function dicehelper(eyes) {
    if (eyes === null || eyes === undefined || eyes === 0) return null;
    switch (eyes) {
      case 1: {
        var div = document.createElement('div');
        div.className = 'dice dice-first-face';
        var span = document.createElement('span');
        span.className = 'dot';
        div.appendChild(span);
        return div;
      }
      case 2: {
        var div = document.createElement('div');
        div.className = 'dice dice-second-face';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        div.appendChild(span);
        div.appendChild(span2);
        return div;
      }
      case 3: {
        var div = document.createElement('div');
        div.className = 'dice dice-third-face';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        var span3 = document.createElement('span');
        span3.className = 'dot';
        div.appendChild(span);
        div.appendChild(span2);
        div.appendChild(span3);
        return div;
      }
      case 4: {
        var div = document.createElement('div');
        div.className = 'dice dice-fourth-face';
        var divc1 = document.createElement('div');
        divc1.className = 'dice-column';
        var divc2 = document.createElement('div');
        divc2.className = 'dice-column';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        var span3 = document.createElement('span');
        span3.className = 'dot';
        var span4 = document.createElement('span');
        span4.className = 'dot';
        divc1.appendChild(span);
        divc1.appendChild(span2);
        divc2.appendChild(span3);
        divc2.appendChild(span4);
        div.appendChild(divc1);
        div.appendChild(divc2);
        return div;
      }
      case 5: {
        var div = document.createElement('div');
        div.className = 'dice dice-fifth-face';
        var divc1 = document.createElement('div');
        divc1.className = 'dice-column';
        var divc2 = document.createElement('div');
        divc2.className = 'dice-column';
        var divc3 = document.createElement('div');
        divc3.className = 'dice-column';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        var span3 = document.createElement('span');
        span3.className = 'dot';
        var span4 = document.createElement('span');
        span4.className = 'dot';
        var span5 = document.createElement('span');
        span5.className = 'dot';
        divc1.appendChild(span);
        divc1.appendChild(span2);
        divc2.appendChild(span3);
        divc3.appendChild(span4);
        divc3.appendChild(span5);
        div.appendChild(divc1);
        div.appendChild(divc2);
        div.appendChild(divc3);
        return div;
      }
      case 6: {
        var div = document.createElement('div');
        div.className = 'dice dice-fourth-face';
        var divc1 = document.createElement('div');
        divc1.className = 'dice-column';
        var divc2 = document.createElement('div');
        divc2.className = 'dice-column';
        var span = document.createElement('span');
        span.className = 'dot';
        var span2 = document.createElement('span');
        span2.className = 'dot';
        var span3 = document.createElement('span');
        span3.className = 'dot';
        var span4 = document.createElement('span');
        span4.className = 'dot';
        var span5 = document.createElement('span');
        span5.className = 'dot';
        var span6 = document.createElement('span');
        span6.className = 'dot';
        divc1.appendChild(span);
        divc1.appendChild(span2);
        divc1.appendChild(span3);
        divc2.appendChild(span4);
        divc2.appendChild(span5);
        divc2.appendChild(span6);
        div.appendChild(divc1);
        div.appendChild(divc2);
        return div;
      }
      default: return null;
    }
  }

  // Format a scoring object (from game.Scoring or game.Last_Scoring) into display HTML
  function formatScoringText(scoring) {
    if (!scoring) return '';
    var chipsPart;
    if (scoring.From === 'schockaus') {
      chipsPart = scoring.From_Name + '! Alle Chips an ' + scoring.To_Name;
    } else {
      chipsPart = scoring.Chips + ' Chip(s) von '
                + scoring.From_Name + ' an ' + scoring.To_Name;
    }
    return '<b>Hoch:</b> ' + scoring.High
         + ' — <b>Tief:</b> ' + scoring.Low
         + ' — ' + chipsPart;
  }

  // Append dice element if non-null
  function appendDice(container, eyes) {
    var el = dicehelper(eyes);
    if (el) container.appendChild(el);
  }

  // ============= 3D Dice Roll Animation =============
  var DICE_FACE_ROTATION = {
    1: { x: 0,   y: 0   },
    2: { x: 0,   y: -90 },
    3: { x: 90,  y: 0   },
    4: { x: -90, y: 0   },
    5: { x: 0,   y: 90  },
    6: { x: 0,   y: 180 }
  };

  function animateDiceCupRoll(oldValues, newValues, inCup) {
    var ANIM_DURATION = 2000;
    var pending = 0;

    for (var i = 0; i < 3; i++) {
      if (inCup[i] && newValues[i] > 0) pending++;
    }
    if (pending === 0) { renderDiceCup(); return; }

    _diceAnimating = true;
    var maxDelay = 0;

    for (var i = 0; i < 3; i++) {
      if (!inCup[i] || !newValues[i] || newValues[i] === 0) continue;

      var delay = Math.floor(Math.random() * 100) + 30;
      if (delay > maxDelay) maxDelay = delay;

      (function(idx, d) {
        var cupCell = document.getElementById('dcell' + idx);
        cupCell.innerHTML = '';
        cupCell.className = 'dcell dcell-cup';

        var scene = document.createElement('div');
        scene.className = 'dice-3d-scene';
        var cube = document.createElement('div');
        cube.className = 'dice-3d-cube';
        scene.appendChild(cube);
        cupCell.appendChild(scene);

        var size = scene.offsetWidth;
        if (!size || size < 10) size = 50;
        var half = size / 2;

        var faceTransforms = [
          'translateZ(' + half + 'px)',
          'rotateY(90deg) translateZ(' + half + 'px)',
          'rotateX(-90deg) translateZ(' + half + 'px)',
          'rotateX(90deg) translateZ(' + half + 'px)',
          'rotateY(-90deg) translateZ(' + half + 'px)',
          'rotateY(180deg) translateZ(' + half + 'px)'
        ];

        for (var face = 1; face <= 6; face++) {
          var faceEl = dicehelper(face);
          if (!faceEl) continue;
          faceEl.style.position = 'absolute';
          faceEl.style.top = '0';
          faceEl.style.left = '0';
          faceEl.style.width = '100%';
          faceEl.style.height = '100%';
          faceEl.style.margin = '0';
          faceEl.style.boxSizing = 'border-box';
          faceEl.style.backfaceVisibility = 'hidden';
          faceEl.style.webkitBackfaceVisibility = 'hidden';
          faceEl.style.transform = faceTransforms[face - 1];
          cube.appendChild(faceEl);
        }

        var oldFace = (oldValues[idx] > 0 && oldValues[idx] <= 6) ? oldValues[idx] : Math.ceil(Math.random() * 6);
        var oldRot = DICE_FACE_ROTATION[oldFace];
        var newRot = DICE_FACE_ROTATION[newValues[idx]];

        cube.style.transform = 'rotateX(' + oldRot.x + 'deg) rotateY(' + oldRot.y + 'deg)';

        setTimeout(function() {
          void cube.offsetHeight;
          var spinsX = (Math.floor(Math.random() * 3) + 2) * 360;
          var spinsY = (Math.floor(Math.random() * 3) + 2) * 360;
          var dirX = Math.random() > 0.5 ? 1 : -1;
          var dirY = Math.random() > 0.5 ? 1 : -1;

          cube.style.transition = 'transform ' + ANIM_DURATION + 'ms cubic-bezier(0.08, 0.82, 0.17, 1)';
          cube.style.transform = 'rotateX(' + (newRot.x + spinsX * dirX) + 'deg) rotateY(' + (newRot.y + spinsY * dirY) + 'deg)';
        }, d);
      })(i, delay);
    }

    setTimeout(function() {
      _diceAnimating = false;
      renderDiceCup();
    }, ANIM_DURATION + maxDelay + 100);
  }

  // C4: Check if any non-passive, non-pending user still has hidden dice
  function isUndecided(game) {
    var undecided = false;
    game.User.forEach(function(user) {
      if (!undecided && user.Passive !== true && user.Pending_Join !== true && user.Dices.length < 3)
        undecided = true;
    });
    return undecided;
  }

  // ============= Dice cup rendering =============
  function clearSwapState() {
    _diceSwapped = [false, false, false];
    _diceSwapCupIdx = -1;
  }

  function isSwapActive() {
    return _diceSwapped[0] || _diceSwapped[1] || _diceSwapped[2];
  }

  function addPlaceholder(cell) {
    var ph = document.createElement('div');
    ph.className = 'dice dice-placeholder';
    cell.appendChild(ph);
  }

  function renderDiceCup() {
    for (var i = 0; i < 6; i++) {
      var cell = document.getElementById('dcell' + i);
      cell.innerHTML = '';
      cell.onclick = null;
      cell.className = (i < 3) ? 'dcell dcell-cup' : 'dcell dcell-out';
    }

    var cupLabel = document.querySelector('.dice-cup-label');
    if (_diceHiddenAfterRoll) {
      for (var i = 0; i < 3; i++) {
        document.getElementById('dcell' + i).classList.add('dcell-cup-covered');
      }
      if (cupLabel) cupLabel.classList.add('dice-cup-label-covered');
    } else {
      if (cupLabel) cupLabel.classList.remove('dice-cup-label-covered');
    }

    for (var i = 0; i < 3; i++) {
      var val = _myDiceValues[i];
      var isNull = (val === null || val === undefined);
      var cupCell = document.getElementById('dcell' + i);
      var outCell = document.getElementById('dcell' + (3 + i));

      if (isNull && _diceSwapped[i] && i === _diceSwapCupIdx) {
        appendDice(cupCell, 6);
        cupCell.classList.add('dcell-disabled');
        addPlaceholder(outCell);
        continue;
      }

      if (!val || val === 0) {
        addPlaceholder(cupCell);
        addPlaceholder(outCell);
        continue;
      }

      if (_diceInCup[i]) {
        appendDice(cupCell, val);
        cupCell.classList.add('dcell-clickable');
        cupCell.onclick = (function(idx) { return function() { toggleDice(idx); }; })(i);
        addPlaceholder(outCell);
      } else {
        addPlaceholder(cupCell);
        appendDice(outCell, val);
        if (_diceSwapped[i]) {
          outCell.classList.add('dcell-swapped', 'dcell-clickable');
          outCell.onclick = (function(idx) { return function() { undoSwap(idx); }; })(i);
        } else {
          outCell.classList.add('dcell-clickable');
          outCell.onclick = (function(idx) { return function() { toggleDice(idx); }; })(i);
        }
      }
    }

    updateTurnButtons();

    // Disable roll button if no dice are in the cup
    var anyInCup = _diceInCup[0] || _diceInCup[1] || _diceInCup[2];
    var btnDice = document.getElementById('btn_dice');
    if (btnDice) {
      if (!anyInCup) {
        btnDice.disabled = true;
      } else if (btnDice.getAttribute('data-cooldown') !== 'true') {
        btnDice.disabled = false;
      }
    }
  }

  function toggleDice(diceIdx) {
    _diceInCup[diceIdx] = !_diceInCup[diceIdx];
    renderDiceCup();
  }

  function updateTurnButtons() {
    var btn2 = document.getElementById('btn_turn_2');
    var btn3 = document.getElementById('btn_turn_3');
    btn2.style.display = 'none';
    btn3.style.display = 'none';

    if (isSwapActive()) return;
    if (_diceHiddenAfterRoll) return;

    var sixes = 0;
    for (var i = 0; i < 3; i++) {
      if (_myDiceValues[i] === 6) sixes++;
    }

    var me = _lastGameState ? _lastGameState.User.find(function(u) { return u.Id === getMyId(); }) : null;
    if (!me || me.Number_Dice === 0) return;
    var firstDiceCount = parseInt(document.getElementById('first_user_dice_count_id').innerHTML) || 3;
    var amFirst = (getMyId() == _lastGameState.First);
    var canRoll = amFirst ? me.Number_Dice < 3 : me.Number_Dice < firstDiceCount;
    if (!canRoll) return;

    if (sixes >= 2) btn2.style.display = '';
    if (sixes >= 3) btn3.style.display = '';
  }

  function turnSixes(count) {
    var gameid = getGameId();
    var id = localStorage.getItem('id');
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/diceturn");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          var newVals = [res.dice1, res.dice2, res.dice3];
          for (var i = 0; i < 3; i++) {
            if (newVals[i] === null || newVals[i] === undefined || newVals[i] === 0) {
              _diceSwapCupIdx = i;
              _diceInCup[i] = true;
              _diceSwapped[i] = true;
              _myDiceValues[i] = null;
            } else if (_myDiceValues[i] === 6 && newVals[i] === 1) {
              _diceInCup[i] = false;
              _diceSwapped[i] = true;
              _myDiceValues[i] = 1;
            } else {
              _myDiceValues[i] = newVals[i];
            }
          }
          renderDiceCup();
        } else {
          alert('' + res.Message);
        }
      }
    }
    xhttp.send(JSON.stringify({ count: count }));
  }

  function undoSwap(diceIdx) {
    var remainingSwapped1s = 0;
    for (var i = 0; i < 3; i++) {
      if (i !== diceIdx && _diceSwapped[i] && _myDiceValues[i] === 1) {
        remainingSwapped1s++;
      }
    }
    var restoreIdx = null;
    if (remainingSwapped1s === 0 && _diceSwapCupIdx >= 0) {
      restoreIdx = _diceSwapCupIdx + 1;
    }

    var gameid = getGameId();
    var id = localStorage.getItem('id');
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/diceturn_undo");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          _myDiceValues[diceIdx] = 6;
          _diceSwapped[diceIdx] = false;
          if (restoreIdx !== null) {
            var cupIdx = _diceSwapCupIdx;
            _myDiceValues[cupIdx] = 6;
            _diceInCup[cupIdx] = false;
            _diceSwapped[cupIdx] = false;
            _diceSwapCupIdx = -1;
          }
          renderDiceCup();
        } else {
          alert('' + res.Message);
        }
      }
    }
    var body = { revert_index: diceIdx + 1 };
    if (restoreIdx !== null) body.restore_index = restoreIdx;
    xhttp.send(JSON.stringify(body));
  }

  // ============= Game Actions =============
  function dice() {
    var _btnDice = document.getElementById("btn_dice");
    _btnDice.disabled = true;
    _btnDice.setAttribute('data-cooldown', 'true');
    setTimeout(function () {
      _btnDice.removeAttribute('data-cooldown');
      var anyInCup = _diceInCup[0] || _diceInCup[1] || _diceInCup[2];
      _btnDice.disabled = !anyInCup;
    }, 2500);

    clearSwapState();
    document.getElementById('btn_turn_2').style.display = 'none';
    document.getElementById('btn_turn_3').style.display = 'none';

    var gameid = getGameId();
    var id = localStorage.getItem('id');

    var dicenumber = document.getElementById('Number_Dice' + id);
    if (dicenumber) {
      var dn = parseInt(dicenumber.innerHTML);
      if (dn == 0) {
        if (!_diceInCup[0] || !_diceInCup[1] || !_diceInCup[2]) {
          alert('Beim ersten Wurf alle Würfel in den Becher Packen!');
          document.getElementById("btn_dice").disabled = false;
          return;
        }
      }
    }

    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/dice");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          if (res.fallen) {
            alert('Würfel vom Tisch gefallen Schnapsrunde!');
          } else {
            playSound(soundDice);

            var firstDiceCount = document.getElementById('first_user_dice_count_id').innerHTML;
            var first_user_id = document.getElementById('first_user_id').innerHTML;
            var me = localStorage.getItem('id');
            var isLastRoll = false;

            if (first_user_id == me) {
              isLastRoll = (res.number_dice >= 3);
            } else {
              isLastRoll = (String(res.number_dice) == firstDiceCount);
            }

            var oldDiceValues = [_myDiceValues[0], _myDiceValues[1], _myDiceValues[2]];
            var rolledInCup = [_diceInCup[0], _diceInCup[1], _diceInCup[2]];

            _myDiceValues = [
              res.dice1 || 0,
              res.dice2 || 0,
              res.dice3 || 0
            ];

            if (isLastRoll) {
              _diceHiddenAfterRoll = true;
              renderDiceCup();
            } else {
              _diceHiddenAfterRoll = false;
              animateDiceCupRoll(oldDiceValues, _myDiceValues, rolledInCup);
            }
          }
        } else {
          alert('' + res.Message);
        }
      }
    }
    _diceOutAtRoll = [!_diceInCup[0], !_diceInCup[1], !_diceInCup[2]];
    xhttp.send(JSON.stringify({ dice1: _diceInCup[0], dice2: _diceInCup[1], dice3: _diceInCup[2] }));
  }

  // Combined End/Pause button handler
  function endpause_click() {
    var btn = document.getElementById('btn_endpause');
    var mode = btn.getAttribute('data-mode');
    var id = localStorage.getItem('id');
    var gameid = getGameId();

    if (mode === 'pause') {
      // Check if player is currently passive -> un-pause
      var me = _lastGameState ? _lastGameState.User.find(function(u) { return u.Id === getMyId(); }) : null;
      var userstate = !(me && me.Passive);
      var xhttp = new XMLHttpRequest();
      xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/passiv");
      xhttp.setRequestHeader("Content-Type", "application/json");
      xhttp.onreadystatechange = function () {
        if (xhttp.readyState == XMLHttpRequest.DONE) {
          var res = JSON.parse(xhttp.responseText);
          if (xhttp.status != 200 && xhttp.status != 201) {
            if (res.Penalty) {
              alert(res.Message);
            } else {
              alert('' + res.Message);
            }
          }
        }
      }
      xhttp.send(JSON.stringify({ userstate: userstate }));
    } else if (mode === 'ende') {
      var xhttp = new XMLHttpRequest();
      xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/finisch");
      xhttp.setRequestHeader("Content-Type", "application/json");
      xhttp.onreadystatechange = function () {
        if (xhttp.readyState == XMLHttpRequest.DONE) {
          var res = JSON.parse(xhttp.responseText);
          if (xhttp.status != 200) { alert('' + res.Message); }
        }
      }
      xhttp.send(JSON.stringify({}));
    }
  }

  function pullup() {
    var id = localStorage.getItem('id');
    var gameid = getGameId();
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/visible");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          _diceHiddenAfterRoll = false;
          renderDiceCup();
        } else {
          alert('' + res.Message);
        }
      }
    }
    xhttp.send(JSON.stringify({ visible: true }));
  }

  function pulldown() {
    var id = localStorage.getItem('id');
    var gameid = getGameId();
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/api/game/" + gameid + "/user/" + id + "/visible");
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        var res = JSON.parse(xhttp.responseText);
        if (xhttp.status == 201) {
          _diceHiddenAfterRoll = true;
          renderDiceCup();
        } else {
          alert('' + res.Message);
        }
      }
    }
    xhttp.send(JSON.stringify({
      dice1_visible: _diceOutAtRoll[0],
      dice2_visible: _diceOutAtRoll[1],
      dice3_visible: _diceOutAtRoll[2]
    }));
  }

  // ============= Player/Admin checks =============
  function checkIfPlayer(game) {
    var myId = getMyId();
    var isPlayer = game.User.some(function(u) { return u.Id === myId; });
    var gameControls = document.getElementById('game_controls');
    var joinForm = document.getElementById('join_form');
    var pendingNotice = document.getElementById('pending_notice');

    if (!isPlayer) {
      var wasHidden = (joinForm.style.display === 'none' || joinForm.style.display === '');
      gameControls.style.display = 'none';
      joinForm.style.display = 'block';
      pendingNotice.style.display = 'none';
      if (wasHidden) {
        var joinInput = document.getElementById('join_name');
        if (joinInput) joinInput.focus();
      }
    } else {
      var me = game.User.find(function(u) { return u.Id === myId; });
      if (me && me.Pending_Join) {
        gameControls.style.display = 'none';
        joinForm.style.display = 'none';
        pendingNotice.style.display = 'block';
      } else {
        gameControls.style.display = 'block';
        joinForm.style.display = 'none';
        pendingNotice.style.display = 'none';
      }
    }
  }

  // ============= Table reorder helpers =============

  function buildSortedOrder(users, firstId) {
    var activeMap = {};
    var pending = [];
    for (var i = 0; i < users.length; i++) {
      if (users[i].Pending_Join) pending.push(users[i]);
      else activeMap[String(users[i].Id)] = users[i];
    }

    // Preserve established rotation: keep known players in their order,
    // remove departed ones, append newly active players at the end
    var newRotation = [];
    for (var i = 0; i < _activeRotation.length; i++) {
      if (activeMap[_activeRotation[i]]) newRotation.push(_activeRotation[i]);
    }
    var inRotation = {};
    for (var i = 0; i < newRotation.length; i++) inRotation[newRotation[i]] = true;
    for (var i = 0; i < users.length; i++) {
      var uid = String(users[i].Id);
      if (!users[i].Pending_Join && !inRotation[uid]) newRotation.push(uid);
    }

    // Rotate so firstId is first
    var firstIdx = -1;
    for (var i = 0; i < newRotation.length; i++) {
      if (newRotation[i] == String(firstId)) { firstIdx = i; break; }
    }
    if (firstIdx > 0) {
      newRotation = newRotation.slice(firstIdx).concat(newRotation.slice(0, firstIdx));
    }
    _activeRotation = newRotation.slice();

    var result = [];
    for (var i = 0; i < newRotation.length; i++) {
      if (activeMap[newRotation[i]]) result.push(activeMap[newRotation[i]]);
    }
    return result.concat(pending);
  }

  function getOrderIds(tbody) {
    var rows = tbody.querySelectorAll('tr');
    var ids = [];
    for (var i = 0; i < rows.length; i++) {
      if (rows[i].id && rows[i].id.startsWith('row') && !rows[i].dataset.removing) {
        ids.push(rows[i].id.replace('row', ''));
      }
    }
    return ids;
  }

  function updateRowCounters(tbody) {
    var rows = tbody.querySelectorAll('tr');
    for (var i = 0; i < rows.length; i++) {
      if (rows[i].cells && rows[i].cells[0]) {
        rows[i].cells[0].textContent = i + 1;
      }
    }
  }

  function flashRowColor(rowId, cssVar) {
    var row = document.getElementById(rowId);
    if (!row || row.dataset.removing) return;
    var color = getComputedStyle(document.documentElement).getPropertyValue(cssVar).trim();
    if (!color) return;
    row.animate([
      { backgroundColor: color },
      { backgroundColor: 'transparent' }
    ], { duration: 2000, easing: 'ease-out' });
  }

  function cancelTableAnimations() {
    for (var i = 0; i < _runningAnims.length; i++) {
      _runningAnims[i].anim.cancel();
      var row = _runningAnims[i].row;
      row.style.transform = '';
      row.style.position = '';
      row.style.zIndex = '';
      row.style.willChange = '';
    }
    _runningAnims = [];
    _tableAnimating = false;
  }

  function animateTableReorder(tbody, oldOrder, newOrder, onComplete) {
    if (_tableAnimating) cancelTableAnimations();

    var moved = false;
    for (var i = 0; i < Math.max(oldOrder.length, newOrder.length); i++) {
      if (oldOrder[i] !== newOrder[i]) { moved = true; break; }
    }
    if (!moved) { if (onComplete) onComplete(); return; }

    _tableAnimating = true;

    var rowEls = {};
    var oldTops = {};
    for (var i = 0; i < oldOrder.length; i++) {
      var uid = oldOrder[i];
      var row = document.getElementById('row' + uid);
      if (row) {
        rowEls[uid] = row;
        oldTops[uid] = row.getBoundingClientRect().top;
      }
    }

    for (var i = 0; i < newOrder.length; i++) {
      var r = rowEls[newOrder[i]];
      if (r) tbody.appendChild(r);
    }

    var deltas = {};
    var anyMoved = false;
    for (var i = 0; i < newOrder.length; i++) {
      var uid = newOrder[i];
      if (!rowEls[uid] || oldTops[uid] === undefined) { deltas[uid] = 0; continue; }
      var newTop = rowEls[uid].getBoundingClientRect().top;
      deltas[uid] = oldTops[uid] - newTop;
      if (Math.abs(deltas[uid]) > 1) anyMoved = true;
    }

    if (!anyMoved) {
      _tableAnimating = false;
      updateRowCounters(tbody);
      _tableOrder = newOrder.slice();
      if (onComplete) onComplete();
      return;
    }

    var newFirstId = newOrder[0];
    var splitIdx = oldOrder.indexOf(newFirstId);
    if (splitIdx <= 0) {
      _tableAnimating = false;
      updateRowCounters(tbody);
      _tableOrder = newOrder.slice();
      if (onComplete) onComplete();
      return;
    }

    var upperGroup = oldOrder.slice(0, splitIdx);
    var lowerGroup = oldOrder.slice(splitIdx);
    var totalRows = upperGroup.length + lowerGroup.length;

    if (totalRows < 2) {
      _tableAnimating = false;
      updateRowCounters(tbody);
      _tableOrder = newOrder.slice();
      if (onComplete) onComplete();
      return;
    }

    // Tight stagger: rows launch shortly after each other, flying in formation
    var stagger = Math.max(55, Math.min(120, 500 / totalRows));
    var flightMs = Math.max(750, Math.min(1300, 550 + totalRows * 80));

    // Build alternating interleaved sequence: bottom of upper, top of lower, …
    var sequence = [];
    var ui = upperGroup.length - 1;
    var li = 0;
    var pickUpper = true;
    while (ui >= 0 || li < lowerGroup.length) {
      if (pickUpper && ui >= 0) {
        sequence.push({ uid: upperGroup[ui], group: 'upper' }); ui--;
        pickUpper = false;
      } else if (!pickUpper && li < lowerGroup.length) {
        sequence.push({ uid: lowerGroup[li], group: 'lower' }); li++;
        pickUpper = true;
      } else if (ui >= 0) {
        sequence.push({ uid: upperGroup[ui], group: 'upper' }); ui--;
      } else {
        sequence.push({ uid: lowerGroup[li], group: 'lower' }); li++;
      }
    }

    var delayMap = {};
    var groupMap = {};
    for (var i = 0; i < sequence.length; i++) {
      delayMap[sequence[i].uid] = i * stagger;
      groupMap[sequence[i].uid] = sequence[i].group;
    }

    _runningAnims = [];
    for (var i = 0; i < newOrder.length; i++) {
      var uid = newOrder[i];
      var row = rowEls[uid];
      if (!row || Math.abs(deltas[uid] || 0) < 1) continue;

      var delta = deltas[uid];
      var delay = delayMap[uid] || 0;
      var isUpper = groupMap[uid] === 'upper';

      row.style.position = 'relative';
      row.style.zIndex = isUpper ? '0' : '10';
      row.style.willChange = 'transform, opacity';

      // Smooth arc: ease-in to midpoint, ease-out to landing.
      // The per-keyframe easings create velocity continuity at the
      // midpoint so the motion feels like one fluid sweep.
      var halfDelta = (delta * 0.5).toFixed(1);
      var kf;
      if (isUpper) {
        kf = [
          { transform: 'translateY(' + delta + 'px) scale(1)',    opacity: 1,   offset: 0,   easing: 'cubic-bezier(0.4, 0, 0.7, 0.4)' },
          { transform: 'translateY(' + halfDelta + 'px) scale(0.95)', opacity: 0.8, offset: 0.5, easing: 'cubic-bezier(0.3, 0.6, 0.6, 1)' },
          { transform: 'translateY(0px) scale(1)',                opacity: 1,   offset: 1.0 }
        ];
      } else {
        kf = [
          { transform: 'translateY(' + delta + 'px) scale(1)',    opacity: 1,   offset: 0,   easing: 'cubic-bezier(0.4, 0, 0.7, 0.4)' },
          { transform: 'translateY(' + halfDelta + 'px) scale(1.04)', opacity: 1, offset: 0.5, easing: 'cubic-bezier(0.3, 0.6, 0.6, 1)' },
          { transform: 'translateY(0px) scale(1)',                opacity: 1,   offset: 1.0 }
        ];
      }

      var anim = row.animate(kf, {
        duration: flightMs,
        delay: delay,
        easing: 'linear',
        fill: 'both'
      });
      _runningAnims.push({ anim: anim, row: row });
    }

    if (_runningAnims.length === 0) {
      _tableAnimating = false;
      updateRowCounters(tbody);
      _tableOrder = newOrder.slice();
      if (onComplete) onComplete();
      return;
    }

    Promise.all(_runningAnims.map(function(a) { return a.anim.finished; })).then(function() {
      for (var i = 0; i < _runningAnims.length; i++) {
        _runningAnims[i].anim.cancel();
        var r = _runningAnims[i].row;
        r.style.transform = '';
        r.style.position = '';
        r.style.zIndex = '';
        r.style.willChange = '';
      }
      _runningAnims = [];
      _tableAnimating = false;
      updateRowCounters(tbody);
      _tableOrder = newOrder.slice();
      if (onComplete) onComplete();
    }).catch(function() {
      _runningAnims = [];
      _tableAnimating = false;
      _tableOrder = newOrder.slice();
      if (onComplete) onComplete();
    });
  }

  // H2: Dynamically rebuild table rows to match game.User
  function updateTableRows(game) {
    var tbody = document.getElementById('game_tbody');
    var myId = getMyId();
    var isAdmin = game.Admins && game.Admins.indexOf(myId) !== -1;
    var showFinal = game.Ruleset && game.Ruleset.play_final;
    var finalHeader = document.getElementById('finalcount_header');
    if (finalHeader) finalHeader.style.display = showFinal ? '' : 'none';

    // Check if any player has penalty > 0
    var anyPenalty = game.User.some(function(u) { return (u.Penalty_Count || 0) > 0; });
    var penaltyHeader = document.getElementById('penalty_header');
    if (penaltyHeader) penaltyHeader.style.display = anyPenalty ? '' : 'none';

    // Build current set of user IDs in table
    var existingRows = {};
    var rows = tbody.querySelectorAll('tr');
    for (var i = 0; i < rows.length; i++) {
      var rowId = rows[i].id;
      if (rowId && rowId.startsWith('row')) {
        existingRows[rowId.replace('row', '')] = rows[i];
      }
    }

    // Remove rows for users no longer in game (animated fade-out)
    var gameUserIds = {};
    game.User.forEach(function(u) { gameUserIds[u.Id] = true; });
    Object.keys(existingRows).forEach(function(uid) {
      if (!gameUserIds[uid] && !existingRows[uid].dataset.removing) {
        var row = existingRows[uid];
        row.dataset.removing = 'true';
        row.animate([
          { opacity: 1, transform: 'scale(1)' },
          { opacity: 0, transform: 'scale(0.85)' }
        ], { duration: 350, easing: 'ease-in', fill: 'forwards' })
        .finished.then(function() {
          if (row.parentNode) row.parentNode.removeChild(row);
        });
      }
    });

    // Add/update rows for each user
    game.User.forEach(function(juser, idx) {
      var row = document.getElementById('row' + juser.Id);
      if (!row) {
        // Create new row
        row = document.createElement('tr');
        row.id = 'row' + juser.Id;
        row.innerHTML = '<td class="col-counter"></td>'
          + '<td id="user' + juser.Id + '" class="col-name"></td>'
          + '<td id="chips' + juser.Id + '" class="col-chips"></td>'
          + '<td id="Number_Dice' + juser.Id + '" class="col-throws"></td>'
          + '<td id="dice1' + juser.Id + '" class="dice-cell col-dice"></td>'
          + '<td id="dice2' + juser.Id + '" class="dice-cell col-dice"></td>'
          + '<td id="dice3' + juser.Id + '" class="dice-cell col-dice"></td>'
          + '<td id="first' + juser.Id + '" class="col-half"></td>'
          + '<td id="finalcount' + juser.Id + '" class="col-final"' + (showFinal ? '' : ' style="display:none"') + '></td>'
          + '<td id="penalty' + juser.Id + '" class="col-penalty"' + (anyPenalty ? '' : ' style="display:none"') + '></td>';
        tbody.appendChild(row);
      }

      // Counter: use first cell directly
      row.cells[0].textContent = idx + 1;

      // G5: Pending player display
      if (juser.Pending_Join) {
        row.className = 'pending-row';
      } else {
        row.className = '';
      }

      // F4: Name + admin badge + leave icon
      var nameCell = document.getElementById('user' + juser.Id);
      var nameHtml = juser.Name;

      // Second line: status and/or leave icon
      var secondLine = '';
      if (juser.Pending_Join) secondLine += '<small>(wartet)</small> ';
      // Leave icon: green if active, gray only if user can toggle it (own or admin)
      var clickable = (juser.Id === myId || isAdmin);
      if (juser.Leave_After_Game) {
        secondLine += '<i class="fas fa-sign-out-alt leave-icon leave-active"'
          + ' title="Verlassen vorgemerkt (klicken zum Aufheben)"'
          + (clickable ? ' onclick="toggle_leave(' + juser.Id + ')"' : '')
          + '></i>';
      } else if (clickable) {
        secondLine += '<i class="fas fa-sign-out-alt leave-icon leave-inactive"'
          + ' title="Nach dem Spiel verlassen"'
          + ' onclick="toggle_leave(' + juser.Id + ')"'
          + '></i>';
      }
      if (secondLine) nameHtml += '<div>' + secondLine + '</div>';
      nameCell.innerHTML = nameHtml;

      // Chips
      document.getElementById('chips' + juser.Id).innerHTML = juser.Chips;

      // Halfcount
      document.getElementById('first' + juser.Id).innerHTML = juser.Halfcount;

      // Finalcount
      var fcEl = document.getElementById('finalcount' + juser.Id);
      if (fcEl) {
        fcEl.innerHTML = juser.Finalcount;
        fcEl.style.display = showFinal ? '' : 'none';
      }

      // Penalty count
      var pcEl = document.getElementById('penalty' + juser.Id);
      if (pcEl) {
        var pc = juser.Penalty_Count || 0;
        pcEl.innerHTML = pc > 0 ? pc : '';
        pcEl.style.display = anyPenalty ? '' : 'none';
      }

      // Number of dice throws
      document.getElementById('Number_Dice' + juser.Id).innerHTML = juser.Number_Dice;

      // Dices in table
      var d1 = document.getElementById('dice1' + juser.Id);
      var d2 = document.getElementById('dice2' + juser.Id);
      var d3 = document.getElementById('dice3' + juser.Id);
      d1.innerHTML = '';
      d2.innerHTML = '';
      d3.innerHTML = '';
      if (juser.Dices && juser.Dices.length > 0) {
        for (var dn in juser.Dices) {
          var jdice = juser.Dices[dn];
          if (jdice['Dice1'] !== undefined) appendDice(d1, jdice['Dice1']);
          if (jdice['Dice2'] !== undefined) appendDice(d2, jdice['Dice2']);
          if (jdice['Dice3'] !== undefined) appendDice(d3, jdice['Dice3']);
        }
      }

      // Row background color via CSS classes (dark-mode safe)
      row.classList.remove('row-passive', 'row-normal', 'row-stripe', 'row-own-player', 'row-active-turn');
      row.style.backgroundColor = '';
      if (juser.Pending_Join) {
        // Already handled by pending-row class
      } else if (juser.Passive) {
        row.classList.add('row-passive');
      } else if (juser.Id == game.Move) {
        row.classList.add('row-active-turn');
      } else {
        row.classList.add('row-normal');
        if (idx % 2 === 1) {
          row.classList.add('row-stripe');
        }
      }
      if (juser.Id == myId) {
        row.classList.add('row-own-player');
      }
    });
  }

  // ============= Main refresh function =============
  function refresh_game(game) {
    _lastGameState = game;
    var gameid = getGameId();
    var waiting_user_id = game.Move;
    var waitinguserstorage = document.getElementById('waiting_id');
    var throwbutton = document.getElementById('startgame_id');
    var id = getMyId();
    var isAdmin = game.Admins && game.Admins.indexOf(id) !== -1;

    // Admin info
    var admininfo = document.getElementById('admin_information');
    if (admininfo) admininfo.innerHTML = 'Admin gespielte Hälften: ' + game['Game_Half_Count'];

    // H2: Toggle admin panel visibility dynamically
    var adminPanel = document.getElementById('admin_interface');
    if (adminPanel) {
      adminPanel.style.display = isAdmin ? 'block' : 'none';
    }

    // Check if player / pending / spectator
    checkIfPlayer(game);

    // Redirect to lobby if game returned to waiting
    var game_state = game['State'];
    if (game_state == 'waiting') {
      var getUrl = window.location;
      var baseUrl = getUrl.protocol + "//" + getUrl.host;
      window.location.replace(baseUrl + '/game_waiting/' + gameid);
      return;
    }

    var me_inactive = false;
    for (var num in game.User) {
      if (game.User[num]['Id'] == id && game.User[num]['Passive']) {
        me_inactive = true;
      }
    }

    // Stack chips
    document.getElementById('StackChips_id').innerHTML = 'Chips: ' + game.Stack;

    // Game phase indicator (1. Hälfte / 2. Hälfte / Finale)
    var phaseCol = document.getElementById('game_phase_col');
    var phaseText = document.getElementById('game_phase_text');
    var chipsCol = document.getElementById('chips_col');
    var showFinalPhase = game.Ruleset && game.Ruleset.play_final;
    if (showFinalPhase) {
      var phaseLabel = '';
      if (game_state == 'playfinal') {
        phaseLabel = 'Finale';
      } else if (game['Game_Half_Count'] >= 1) {
        phaseLabel = '2. H\u00e4lfte';
      } else {
        phaseLabel = '1. H\u00e4lfte';
      }
      phaseText.innerHTML = phaseLabel;
      phaseCol.style.display = '';
      chipsCol.className = 'col-xs-6 col-md-2';
    } else {
      phaseCol.style.display = 'none';
      chipsCol.className = 'col-xs-6 col-md-offset-1 col-md-2';
    }

    // First user
    var firstuser_id = game['First'];
    document.getElementById('first_user_id').innerHTML = firstuser_id;

    // First user dice count
    for (var num in game.User) {
      if (game.User[num].Id == firstuser_id) {
        var anzahlel = document.getElementById('throw_id');
        var anzahl_number_el = document.getElementById('throw_number_id');
        anzahlel.innerHTML = 'Würfe: ' + game.User[num]['Number_Dice'];
        anzahl_number_el.innerHTML = game.User[num]['Number_Dice'];
        document.getElementById('first_user_dice_count_id').innerHTML = game.User[num]['Number_Dice'];
        break;
      }
    }

    // Game message
    var el_message = document.getElementById('Message');
    if (game.Message) {
      if (el_message.innerHTML != 'Nachricht: ' + game.Message) {
        el_message.className = "message";
        el_message.style.animation = 'none';
        el_message.offsetHeight;
        el_message.style.animation = null;
      }
      el_message.innerHTML = 'Nachricht: ' + game.Message;
    } else {
      el_message.innerHTML = '';
    }

    // Count active (non-pending) players
    var activePlayerCount = 0;
    for (var num in game.User) {
      if (!game.User[num].Pending_Join) activePlayerCount++;
    }
    var notEnoughPlayers = activePlayerCount < 2 &&
        (game_state == 'started' || game_state == 'playfinal');

    // C4: Improved "Warten auf" display
    if (notEnoughPlayers) {
      waitinguserstorage.innerHTML = 'Warten auf: Mitspieler';
    } else if (waiting_user_id == -1) {
      if (isUndecided(game)) {
        waitinguserstorage.innerHTML = 'Warten auf: Aufdecken';
      } else {
        waitinguserstorage.innerHTML = 'Warten auf: Chip Verteilung';
      }
    } else {
      // Find the waiting user's name
      for (var num in game.User) {
        if (game.User[num]['Id'] == waiting_user_id) {
          waitinguserstorage.innerHTML = 'Warten auf: ' + game.User[num]['Name'];
          break;
        }
      }
    }

    // Play "your turn" sound when the waiting user changes to me.
    // _lastWaitingUserId === undefined on first load → suppress sound on page load.
    if (_lastWaitingUserId !== undefined
        && waiting_user_id !== _lastWaitingUserId
        && waiting_user_id === id) {
      playSound(soundDiceY);
    }
    _lastWaitingUserId = waiting_user_id;

    // Sort users so the round starter is first (preserving rotation order)
    if (game.First) {
      game.User = buildSortedOrder(game.User, game.First);
    }

    // H2: Update table rows dynamically
    var tbody = document.getElementById('game_tbody');

    updateTableRows(game);

    var desiredOrder = game.User.map(function(u) { return String(u.Id); });

    if (_isFirstTableLoad) {
      // First load: reorder DOM without animation
      for (var i = 0; i < desiredOrder.length; i++) {
        var r = document.getElementById('row' + desiredOrder[i]);
        if (r) tbody.appendChild(r);
      }
      updateRowCounters(tbody);
      _tableOrder = desiredOrder.slice();
      _isFirstTableLoad = false;
    } else {
      var currentDomOrder = getOrderIds(tbody);
      var needsReorder = false;
      for (var ni = 0; ni < desiredOrder.length; ni++) {
        if (currentDomOrder[ni] !== desiredOrder[ni]) { needsReorder = true; break; }
      }
      if (needsReorder) {
        animateTableReorder(tbody, currentDomOrder, desiredOrder);
      }
    }

    // C1: Restore own dice cup from server state
    var me_data = null;
    for (var num in game.User) {
      if (game.User[num].Id == id) {
        me_data = game.User[num];
        break;
      }
    }
    if (me_data) {
      // Reset dice state at the start of each round (before first roll)
      if (me_data.Number_Dice == 0) {
        _diceInCup = [true, true, true];
        _myDiceValues = [0, 0, 0];
        _diceOutAtRoll = [false, false, false];
        clearSwapState();
        _diceHiddenAfterRoll = false;
      }

      // Fill in dice values from server state (page reload or after pullup)
      if (me_data.Number_Dice > 0 && me_data.Dices && me_data.Dices.length > 0) {
        var anyFilled = false;
        for (var dn in me_data.Dices) {
          var jdice = me_data.Dices[dn];
          if (jdice['Dice1'] !== undefined && _myDiceValues[0] === 0) {
            _myDiceValues[0] = jdice['Dice1'];
            anyFilled = true;
          }
          if (jdice['Dice2'] !== undefined && _myDiceValues[1] === 0) {
            _myDiceValues[1] = jdice['Dice2'];
            anyFilled = true;
          }
          if (jdice['Dice3'] !== undefined && _myDiceValues[2] === 0) {
            _myDiceValues[2] = jdice['Dice3'];
            anyFilled = true;
          }
        }
        // After pullup reveals all dice, clear hidden state
        if (_myDiceValues[0] > 0 && _myDiceValues[1] > 0 && _myDiceValues[2] > 0) {
          _diceHiddenAfterRoll = false;
        }
        if (anyFilled) {
          _diceOutAtRoll = [!_diceInCup[0], !_diceInCup[1], !_diceInCup[2]];
        }
      } else if (me_data.Number_Dice > 0 && (!me_data.Dices || me_data.Dices.length === 0)
                 && _myDiceValues[0] === 0 && _myDiceValues[1] === 0 && _myDiceValues[2] === 0) {
        _diceHiddenAfterRoll = true;
      }

      if (!_diceAnimating) renderDiceCup();
    }

    // End/Pause button logic
    var btnEP = document.getElementById('btn_endpause');
    var gameControls = document.getElementById('game_controls');
    if (btnEP && me_data) {
      var isMyTurn = (id == waiting_user_id);
      var myDiceCount = me_data.Number_Dice;
      var firstDiceCount = parseInt(document.getElementById('first_user_dice_count_id').innerHTML) || 3;
      var amFirst = (id == game['First']);
      var penaltyCount = me_data.Penalty_Count || 0;
      var canPause = (game.Stack == 0 && me_data.Chips == 0 && game_state != 'playfinal');

      // Remove paused overlay by default
      gameControls.classList.remove('controls-paused');

      if (me_data.Passive && game_state == 'playfinal') {
        // Non-finalist in finale: fully disabled controls, no unpause
        btnEP.textContent = 'Pause';
        btnEP.setAttribute('data-mode', 'pause');
        btnEP.disabled = true;
        btnEP.className = 'btn btn-endpause btn-pause-locked';
        gameControls.classList.add('controls-paused');
      } else if (me_data.Passive) {
        // Player is paused: show Pause button to un-pause, gray out controls
        btnEP.textContent = 'Pause';
        btnEP.setAttribute('data-mode', 'pause');
        btnEP.disabled = false;
        btnEP.className = 'btn btn-endpause btn-pause-locked';
        gameControls.classList.add('controls-paused');
      } else if (myDiceCount == 0) {
        // Start of round: show Pause button (available to all players, not just active)
        btnEP.textContent = 'Pause';
        btnEP.setAttribute('data-mode', 'pause');
        btnEP.className = 'btn btn-primary btn-endpause';

        if (game_state == 'playfinal') {
          // Finale: pause is never allowed
          btnEP.disabled = true;
        } else if (notEnoughPlayers) {
          btnEP.disabled = true;
        } else if (canPause && penaltyCount > 0) {
          // Must roll instead of pausing (penalty)
          btnEP.disabled = true;
        } else {
          // Either can legitimately pause, or pressing will trigger penalty
          btnEP.disabled = false;
        }
      } else {
        // After rolling: show Ende button
        btnEP.textContent = 'Ende';
        btnEP.setAttribute('data-mode', 'ende');
        btnEP.className = 'btn btn-primary btn-endpause';

        if (!isMyTurn || notEnoughPlayers) {
          btnEP.disabled = true;
        } else if (isSwapActive()) {
          btnEP.disabled = true;
        } else {
          // Active while player can still roll
          var canStillRoll = false;
          if (amFirst) {
            canStillRoll = myDiceCount < 3;
          } else {
            canStillRoll = myDiceCount < firstDiceCount;
          }
          btnEP.disabled = !canStillRoll;
        }
      }
    }

    // Throw button color and state
    if (notEnoughPlayers) {
      throwbutton.className = 'buttongray containerturner';
      throwbutton.disabled = true;
    } else if (id == waiting_user_id) {
      throwbutton.className = 'buttongreen containerturner';
      throwbutton.disabled = false;
    } else {
      throwbutton.className = 'buttongray containerturner';
      throwbutton.disabled = false;
    }

    // Unified round status row
    var roundRow = document.getElementById('round_status_row');
    var roundFinished = (waiting_user_id == -1);
    var needsReveal = roundFinished && isUndecided(game);
    var readyToDistribute = roundFinished && !needsReveal;

    // Play reveal sound only on transition into the reveal phase,
    // and only for active players who still have hidden dice
    if (needsReveal && !_wasInRevealPhase) {
      if (me_data && !me_data.Passive && !me_data.Pending_Join
          && me_data.Dices.length < 3 && me_data.Number_Dice > 0) {
        playSound(soundLift);
      }
    }
    _wasInRevealPhase = needsReveal;

    var newPhase = 'idle';
    if (readyToDistribute && game.Scoring) {
      newPhase = 'distribute';
    } else if (needsReveal) {
      newPhase = 'reveal';
    } else if (!roundFinished) {
      newPhase = 'running';
    }

    if (newPhase === 'distribute') {
      var fullInfo = formatScoringText(game.Scoring);
      if (_currentRoundPhase !== 'distribute') {
        // Flash high (green) and low (red) rows when distribute button appears
        if (game.Scoring) {
          if (game.Scoring.High_Id) flashRowColor('row' + game.Scoring.High_Id, '--flash-high');
          if (game.Scoring.Low_Id)  flashRowColor('row' + game.Scoring.Low_Id, '--flash-low');
        }
        roundRow.innerHTML = '<button class="btn btn-success" id="distribute_btn" '
          + 'onclick="distribute()" disabled>Verteilen</button> '
          + '<span id="round_info_text">' + fullInfo + '</span>';
        setTimeout(function() {
          var btn = document.getElementById('distribute_btn');
          if (btn) btn.disabled = false;
        }, 3000);
      } else {
        var infoSpan = document.getElementById('round_info_text');
        if (infoSpan) infoSpan.innerHTML = fullInfo;
      }
    } else if (newPhase === 'reveal') {
      var voteHtml = '';
      if (game.Reveal_Votes > 0) {
        voteHtml = ' <span id="reveal_votes">(' + game.Reveal_Votes + ' Stimme(n))</span>';
      }
      if (_currentRoundPhase !== 'reveal') {
        roundRow.innerHTML = '<button class="btn btn-warning" id="reveal_all_btn" onclick="vote_reveal_all()" disabled>'
          + 'Alles aufdecken</button>' + voteHtml;
        setTimeout(function() {
          var btn = document.getElementById('reveal_all_btn');
          if (btn) btn.disabled = false;
        }, 10000);
      } else {
        var existingVotes = document.getElementById('reveal_votes');
        if (game.Reveal_Votes > 0) {
          if (existingVotes) {
            existingVotes.innerHTML = '(' + game.Reveal_Votes + ' Stimme(n))';
          } else {
            var revealBtn = document.getElementById('reveal_all_btn');
            if (revealBtn) {
              revealBtn.insertAdjacentHTML('afterend', ' <span id="reveal_votes">(' + game.Reveal_Votes + ' Stimme(n))</span>');
            }
          }
        } else if (existingVotes) {
          existingVotes.remove();
        }
      }
    } else if (newPhase === 'running') {
      var lastText = formatScoringText(game.Last_Scoring);
      if (lastText) {
        roundRow.innerHTML = '<span>Letzte Runde: ' + lastText + '</span>';
      } else {
        roundRow.innerHTML = '';
      }
    } else {
      roundRow.innerHTML = '';
    }
    _currentRoundPhase = newPhase;

    // Lobby after game button
    var lobbyBtn = document.getElementById('mark_lobby_btn');
    if (lobbyBtn) {
      if (game.Lobby_After_Game) {
        lobbyBtn.className = 'btn btn-success btn-sm';
        lobbyBtn.innerHTML = 'Lobby nach dem Spiel geplant (klicken zum Aufheben)';
      } else {
        lobbyBtn.className = 'btn btn-warning btn-sm';
        lobbyBtn.innerHTML = 'Zurück zur Lobby nach dem Spiel';
      }
    }

    // H2: Update player select lists
    if (typeof updatePlayerSelects === 'function') {
      updatePlayerSelects(game);
    }

    // R6: Update rules display data
    if (game.Ruleset) {
      updateRulesModal(game.Ruleset);
    }
  }

  // R6: Build rules modal content
  function updateRulesModal(ruleset) {
    var title = document.getElementById('rules_title');
    var content = document.getElementById('rules_content');
    if (!title || !content) return;
    title.innerHTML = 'Regeln: ' + ruleset.name;
    var html = '<p><strong>Chips:</strong> ' + ruleset.stack_max + ' | <strong>Finale:</strong> ' + (ruleset.play_final ? 'Ja' : 'Nein') + '</p>';
    html += '<table class="table table-condensed"><thead><tr><th>Kombination</th><th>Name</th><th>Chips</th></tr></thead><tbody>';
    for (var i = 0; i < ruleset.rules.length; i++) {
      var r = ruleset.rules[i];
      html += '<tr><td>' + r.dice + '</td><td>' + r.name + '</td><td>' + (r.chips == -1 ? 'Alle (' + r.name + ')' : r.chips) + '</td></tr>';
    }
    html += '</tbody></table>';
    html += '<p><small>Alle weiteren Kombinationen: Schrott (1 Chip)</small></p>';
    content.innerHTML = html;
  }

  function initial_game_data() {
    var gameid = getGameId();
    var xhttp = new XMLHttpRequest();
    xhttp.open("GET", "/api/game/" + gameid);
    xhttp.setRequestHeader("Content-Type", "application/json");
    xhttp.onreadystatechange = function () {
      if (xhttp.readyState == XMLHttpRequest.DONE) {
        if (xhttp.status == 200) {
          var res = JSON.parse(xhttp.responseText);
          refresh_game(res);
        }
      }
    }
    xhttp.send(JSON.stringify({}));
  }

  function startup() {
    var id = localStorage.getItem('id');
    var user = document.getElementById('ownuser');
    user.innerHTML = "Spieler: " + (localStorage.getItem('name') || '');
    // Pre-fill mid-game join input from localStorage
    var savedName = localStorage.getItem('name');
    if (savedName) {
      var joinInput = document.getElementById('join_name');
      if (joinInput && !joinInput.value) joinInput.value = savedName;
    }
    initial_game_data();
  }

  startup();

  document.addEventListener('DOMContentLoaded', function() {
    var container = document.getElementById('floating-icons');
    if (container) {
      var btn = document.createElement('a');
      btn.className = 'floating-icon-btn';
      btn.href = '#';
      btn.onclick = function(e) { e.preventDefault(); showRules(); };
      btn.title = 'Regeln';
      btn.innerHTML = '<i class="fas fa-book"></i>';
      container.insertBefore(btn, container.firstChild);
    }
    var rulesModal = document.getElementById('rulesModal');
    if (rulesModal) {
      window.addEventListener('click', function(e) {
        if (e.target === rulesModal) rulesModal.style.display = 'none';
      });
    }
  });
</script>
<script type="text/javascript" charset="utf-8">
  namespace = '/game';

  const socket = io(namespace, {
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    randomizationFactor: 0.5
  });

  socket.on('connect', function () {
    var game = document.getElementById('UUID');
    var gameid = game.innerHTML;
    gameid = gameid.replace(/^"(.+)"$/, '$1');
    socket.emit('join', { room: gameid });
  });

  socket.on('reload_game', function (game) {
    if (game) {
      refresh_game(game);
    }
  });
</script>
{% endblock %}
